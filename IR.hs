-----------------------------------------------------------------------------
---- |
---- Module      :  IR
---- Copyright   :  (c) Syoyo Fujita
---- License     :  BSD-style
----
---- Maintainer  :  syoyo@lighttransport.com
---- Stability   :  experimental
---- Portability :  GHC 7.6
----
---- IR          : Intermediate Representation for MUDA language.
----               Do AST(Generated by BNFC's parser) -> IR conversion.
----
-------------------------------------------------------------------------------
module IR where

import Debug.Trace
import Control.Monad.Except

import Text.ParserCombinators.Parsec
import qualified Text.ParserCombinators.Parsec.Token as P
import Text.ParserCombinators.Parsec.Language

import qualified AbsMUDA as AST
import qualified TypeMUDA as T
import PrintMUDA
import Sym
import ErrM


newtype Ident = Ident String deriving (Eq,Ord,Show)

-- length = 1 or 4
type SwizzleIndex = [Int]


data Prog =
   Program [Struc] [Func]
  deriving (Eq,Ord,Show)

data Struc =
   Struct Ident [MDec]
  deriving (Eq,Ord,Show)

data MDec =
   MDecl Typ Ident Ident      -- type, field id, struct id
  deriving (Eq,Ord,Show)

data Func =
   Fun [FuncSpec] Typ Ident [FormalDec] [Stm]
  deriving (Eq,Ord,Show)

data FuncSpec =
   InlineFuncSpec
 | ForceInlineFuncSpec
 | AlwaysInlineFuncSpec
 | StaticFuncSpec
  deriving (Eq,Ord,Show)

data FormalDec =
   FormalDecl Sym [Qual] Typ Ident
  deriving (Eq,Ord,Show)

data DecInit =
   DeclInit Ident [DecInitExp]
  deriving (Eq,Ord,Show)

data DecInitExp =
   DExp Sym Exp
  deriving (Eq,Ord,Show)

data Qual =
   NoneQual
 | InputQual
 | OutputQual
 | InOutQual
 | ArrayQual
  deriving (Eq,Ord,Show)

--
-- Tree-address form
--
data Stm =
   SDecl                Sym Typ DecInit
 | SAssign              Sym Ident Exp
 | SAssignWithField     Sym Ident [Field] Exp       -- TODO: to be removed?
 | SAssignWithArray     Sym Ident Exp Exp
 | SAssignWithSwizzle   Sym Ident SwizzleIndex Exp
 | SExp                 Exp
 | SBlock               [Stm]
 | SWhile               Exp [Stm]
 | SIf                  Exp [Stm] [Stm]
 | SReturn              Exp               
 | SReturnVoid          
 | SNew                 Ident Integer           -- TODO
  deriving (Eq,Ord,Show)

data Exp =
   EAnd            Sym Exp Exp
 | EOr             Sym Exp Exp
 | EXor            Sym Exp Exp
 | ENot            Sym Exp Exp
 | EEq             Sym Exp Exp
 | ENeq            Sym Exp Exp
 | EGt             Sym Exp Exp
 | EGte            Sym Exp Exp
 | ELt             Sym Exp Exp
 | ELte            Sym Exp Exp
 | ESlElemWise     Sym Exp Exp
 | ESrElemWise     Sym Exp Exp
 | ESlQWord        Sym Exp Exp
 | ESrQWord        Sym Exp Exp
 | EAdd            Sym Exp Exp
 | ESub            Sym Exp Exp
 | EMul            Sym Exp Exp
 | EDiv            Sym Exp Exp
 | EDivApprox      Sym Exp Exp
 | ENeg            Sym Exp
 | EIdent          Sym Ident
-- | EIdentWithField Sym Ident [Field]
 | EInt            Sym Integer
 | EFloat          Sym Double
 | EDouble         Sym Double
-- | ECFloat         Sym Double
-- | EHexadec Hexadecimal
 | EArray          Sym Exp Exp
 | EFunc           Sym Ident [Exp]
 | EFtoD           Sym Exp            -- float to double
 | EVtoDV          Sym Exp            -- fvec to dvec
 | EFtoV           Sym Exp            -- float to vector
 | EVtoF           Sym Exp            -- vector to float
 | EDtoDV          Sym Exp            -- double to dvec
 | EDVtoD          Sym Exp            -- dvec to double
 | EItoIV          Sym Exp            -- int to int vector
 | EIVtoI          Sym Exp            -- int vector to int
 | EBtoV           Sym Exp            -- bit to vector

   -- Internal representation

 | ELoad           Sym Exp
 | EStore          Sym Exp

   -- Intrinsic functions.
   -- Backend must supply an implementations for this functions.

 | EVecInit        Sym [Exp]          -- a = vec(1.0), 1 or 4 args
 | EDVecInit       Sym [Exp]          -- a = dec(1.0), 1 or 4 args
 | ESel            Sym [Exp]          -- if (a[x]) ? b[x] : c[x], 3 args
 | EGather         Sym [Exp]          -- movemask(exp), 1 arg
 | EExtract        Sym [Exp]          -- extract(a, b), 2 args
 | EInsert         Sym [Exp]          -- insert(a, b, c), 3 args
 | EFrac           Sym [Exp]          -- frac(a), 1 args
 | EBit            Sym [Exp]          -- bit(a), 1 args
 | EItoF           Sym [Exp]          -- itof(a), 1 args
 | EFtoI           Sym [Exp]          -- ftoi(a), 1 args
 | ERsqrt          Sym [Exp]          -- 1/sqrt(a), 1 args
 | ECeil           Sym [Exp]          -- ceil(a), 1 args
 | EFloor          Sym [Exp]          -- floor(a), 1 args
 | ETrunc          Sym [Exp]          -- trunc(a), 1 args
 | ERound          Sym [Exp]          -- round(a), 1 args
 | EMin            Sym [Exp]          -- min(a, b), 2 args
 | EMax            Sym [Exp]          -- max(a, b), 2 args
 | EAll            Sym [Exp]          -- all(a), 1 args
 | EAny            Sym [Exp]          -- any(a), 1 args
 | EAbs            Sym [Exp]          -- abs(a), 1 args
 | EExp            Sym [Exp]          -- exp(a), 1 args
 | EFastExp        Sym [Exp]          -- fastexp(a), 1 args
 | ESqrt           Sym [Exp]          -- sqrt(a), 1 args
 | ELog            Sym [Exp]          -- log(a), 1 args
 | ELog2           Sym [Exp]          -- log2(a), 1 args
 | EFastLog        Sym [Exp]          -- fastlog(a), 1 args
 | EFastLog2       Sym [Exp]          -- fastlog2(a), 1 args
 | EPow            Sym [Exp]          -- pow(a, b), 2 args
 | EAsVec          Sym [Exp]          -- as_vec(a), 1 args
 | EAsIVec         Sym [Exp]          -- as_ivec(a), 1 args

   -- Swizzle
 
 | ESwizzle        Sym SwizzleIndex Exp

   -- Field Selection
   -- e.g.  val.item  -> EFieldSelect sym "item" "val"
   --      a[0].item  -> EFieldSelect sym "item" "a[0]"

 | EFieldSelect    Sym Ident Exp

  deriving (Eq,Ord,Show)

data FuncArgs =
   EArg Exp
  deriving (Eq,Ord,Show)

data Field =
   EField Ident
  deriving (Eq,Ord,Show)

data Typ =
   TName Ident
  deriving (Eq,Ord,Show)


--
-- mapSeq ensures sequential execution so that symbol management works
-- correctly.
--
mapSeq :: (a -> b) -> [a] -> [b]
mapSeq f [] = []
mapSeq f (x:xs) = lhs `seq` lhs : map f xs
                  where lhs = f x


getSymFromDExp :: IR.DecInitExp -> Sym.Sym
getSymFromDExp e = case e of
  IR.DExp sym exp -> getSymFromExp exp  -- sym isn't needed?


getSymFromExp :: IR.Exp -> Sym.Sym
getSymFromExp s = case s of
  IR.EFloat       sym _   -> sym 
  IR.EDouble      sym _   -> sym 
  IR.EInt         sym _   -> sym 
  IR.EFtoD        sym _   -> sym 
  IR.EVtoDV       sym _   -> sym 
  IR.EFtoV        sym _   -> sym 
  IR.EVtoF        sym _   -> sym 
  IR.EDtoDV       sym _   -> sym 
  IR.EDVtoD       sym _   -> sym 
  IR.EItoIV       sym _   -> sym 
  IR.EIVtoI       sym _   -> sym 
  IR.EBtoV        sym _   -> sym 
  IR.EIdent       sym _    -> sym
--   IR.EIdentWithField     sym _ _   -> sym     -- TODO: to be removed.
  IR.ESwizzle     sym _ _   -> sym
  IR.EAnd         sym _ _   -> sym
  IR.EOr          sym _ _   -> sym
  IR.EXor         sym _ _   -> sym
  IR.ENot         sym _ _   -> sym
  IR.EEq          sym _ _   -> sym
  IR.ENeq         sym _ _   -> sym
  IR.EGt          sym _ _   -> sym
  IR.EGte         sym _ _   -> sym
  IR.ELt          sym _ _   -> sym
  IR.ELte         sym _ _   -> sym
  IR.ESlElemWise  sym _ _   -> sym
  IR.ESrElemWise  sym _ _   -> sym
  IR.ESlQWord     sym _ _   -> sym 
  IR.ESrQWord     sym _ _   -> sym
  IR.EAdd         sym _ _   -> sym
  IR.ESub         sym _ _   -> sym
  IR.EMul         sym _ _   -> sym
  IR.EDiv         sym _ _   -> sym
  IR.EDivApprox   sym _ _   -> sym
  IR.ENeg         sym _     -> sym
  IR.EArray       sym _ _   -> sym
  IR.EFunc        sym _ _   -> sym
  IR.EVecInit     sym _     -> sym
  IR.EDVecInit    sym _     -> sym
  IR.ESel         sym _     -> sym
  IR.EExtract     sym _     -> sym
  IR.EFrac        sym _     -> sym
  IR.EBit         sym _     -> sym
  IR.EItoF        sym _     -> sym
  IR.EFtoI        sym _     -> sym
  IR.ERsqrt       sym _     -> sym
  IR.ECeil        sym _     -> sym
  IR.EFloor       sym _     -> sym
  IR.ETrunc       sym _     -> sym
  IR.ERound       sym _     -> sym
  IR.EMin         sym _     -> sym
  IR.EMax         sym _     -> sym
  IR.EGather      sym _     -> sym
  IR.EAll         sym _     -> sym
  IR.EAny         sym _     -> sym
  IR.EAbs         sym _     -> sym
  IR.EExp         sym _     -> sym
  IR.ELog         sym _     -> sym
  IR.ELog2        sym _     -> sym
  IR.EFastExp     sym _     -> sym
  IR.EFastLog     sym _     -> sym
  IR.EFastLog2    sym _     -> sym
  IR.ESqrt        sym _     -> sym
  IR.EPow         sym _     -> sym
  IR.EAsVec       sym _     -> sym
  IR.EAsIVec      sym _     -> sym
  IR.EFieldSelect sym _ _   -> sym
  IR.ELoad        sym _     -> sym
  IR.EStore       sym _     -> sym
  _                   -> error ("[IR] TODO: getSymFromExp " ++ (show s))

convIdent :: AST.Ident -> IR.Ident
convIdent (AST.Ident i) = (IR.Ident i)

convType :: AST.Typ -> IR.Typ
convType (AST.TName (AST.Ident id)) = TName (IR.Ident id)

convTypeMUDA :: IR.Typ -> T.Typ
convTypeMUDA (TName (IR.Ident str)) = T.typeFromString str

convQualMUDA :: IR.Qual -> T.Qual
convQualMUDA q = case q of
    IR.NoneQual   -> T.NoneQual
    IR.InputQual  -> T.InputQual
    IR.OutputQual -> T.OutputQual
    IR.InOutQual  -> T.InOutQual
    IR.ArrayQual  -> T.ArrayQual

convFuncArg :: AST.FuncArgs -> IR.Exp
convFuncArg (AST.EArg exp) = convExpr exp

convCFloat :: AST.CFloat -> Double
convCFloat (AST.CFloat str) = readFloatingPoint str

convHexa :: AST.Hexadecimal -> Integer
convHexa (AST.Hexadecimal str) = read str :: Integer



convFieldAndExp :: AST.Field -> IR.Exp -> IR.Exp
convFieldAndExp (AST.EField (AST.Ident str)) exp
  = IR.EFieldSelect Sym.nilSym (IR.Ident str) exp

convField :: AST.Field -> IR.Field
convField (AST.EField (AST.Ident str)) = IR.EField (IR.Ident str)

convFieldToIdent :: AST.Field -> IR.Ident
convFieldToIdent (AST.EField id) = convIdent id

convFirstFieldToIdent :: [AST.Field] -> IR.Ident
convFirstFieldToIdent fields = convFieldToIdent (fields !! 0)


-- TODO: refactor?
convExpr :: AST.Exp -> IR.Exp
convExpr e = case e of
  -- upcast to vector 
  AST.EDouble    val   -> IR.EDtoDV Sym.nilSym (IR.EDouble Sym.nilSym val)
  -- AST.EFloat     val   -> IR.EFtoV  Sym.nilSym (IR.EFloat Sym.nilSym val)
  AST.ECFloat    val   -> IR.EFtoV  Sym.nilSym (IR.EFloat Sym.nilSym (convCFloat val))
  AST.EHexadec   val   -> IR.EItoIV Sym.nilSym (IR.EInt Sym.nilSym (convHexa val))
  AST.EInt       val   -> IR.EItoIV Sym.nilSym (IR.EInt Sym.nilSym val)
  AST.EIdent     id    -> IR.EIdent Sym.nilSym (convIdent id)
  -- AST.EIdentWithField  id (f:fs) -> convFieldAndExp f (IR.EIdent Sym.nilSym (convIdent id))
--  AST.EIdentWithField  id fs -> IR.EIdentWithField Sym.nilSym (convIdent id) (map convField fs)
  AST.EFieldSelect e0 fields -> IR.EFieldSelect Sym.nilSym (convFirstFieldToIdent fields) (convExpr e0)
  AST.EAnd       e0 e1 -> IR.EAnd Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EOr        e0 e1 -> IR.EOr  Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EXor       e0 e1 -> IR.EXor Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ENot       e0 e1 -> IR.ENot Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EEq        e0 e1 -> IR.EEq  Sym.nilSym (convExpr e0) (convExpr e1)  
  AST.ENeq       e0 e1 -> IR.ENeq Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EGt        e0 e1 -> IR.EGt  Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EGte       e0 e1 -> IR.EGte Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ELt        e0 e1 -> IR.ELt  Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ELte       e0 e1 -> IR.ELte Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ESlElemWise e0 e1 -> IR.ESlElemWise Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ESrElemWise e0 e1 -> IR.ESrElemWise Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ESlQWord   e0 e1 -> IR.ESlQWord Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ESrQWord   e0 e1 -> IR.ESrQWord Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EAdd       e0 e1 -> IR.EAdd Sym.nilSym (convExpr e0) (convExpr e1)
  AST.ESub       e0 e1 -> IR.ESub Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EMul       e0 e1 -> IR.EMul Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EDiv       e0 e1 -> IR.EDiv Sym.nilSym (convExpr e0) (convExpr e1)
  AST.EDivApprox e0 e1 -> IR.EDivApprox Sym.nilSym (convExpr e0) (convExpr e1)

  -- EFloat cannot parse signed floating point value, thus input value of -1.0
  -- is parsed as (ENeg (EFloat 1.0)) 
  -- We simplify convert it into (Efloat -1.0). 

  AST.ENeg       (AST.ECFloat val)
                       -> IR.EFtoV  Sym.nilSym (IR.EFloat Sym.nilSym (negate (convCFloat val)))
  AST.ENeg       (AST.EDouble val)
                       -> IR.EDtoDV Sym.nilSym (IR.EDouble Sym.nilSym (negate val))

  -- Do same as (ENeg (EFloat _))
  AST.ENeg       (AST.EInt val)
                       -> IR.EItoIV  Sym.nilSym (IR.EInt Sym.nilSym (negate val))
  AST.ENeg       e0    -> IR.ENeg Sym.nilSym (convExpr e0)


  --
  -- e[idx]
  --
  AST.EArray     exp idxExp
                       -> IR.EArray Sym.nilSym (convExpr exp) (convExpr idxExp)
 

  AST.EFunc      id args
    | (strOfIdent id) == "vec"
      -> IR.EVecInit Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "dvec"
      -> IR.EDVecInit Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "sel"
      -> IR.ESel Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "extract"
      -> IR.EExtract Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "frac"
      -> IR.EFrac Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "bit"
      -> IR.EBit Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "itof"
      -> IR.EItoF Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "ftoi"
      -> IR.EFtoI Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "rsqrt"
      -> IR.ERsqrt Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "ceil"
      -> IR.ECeil Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "floor"
      -> IR.EFloor Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "trunc"
      -> IR.ETrunc Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "round"
      -> IR.ERound Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "min"
      -> IR.EMin Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "max"
      -> IR.EMax Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "gather"
      -> IR.EGather Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "all"
      -> IR.EAll Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "any"
      -> IR.EAny Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "abs"
      -> IR.EAbs Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "exp"
      -> IR.EExp Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "log"
      -> IR.ELog Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "log2"
      -> IR.ELog2 Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "fastexp"
      -> IR.EFastExp Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "fastlog"
      -> IR.EFastLog Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "fastlog2"
      -> IR.EFastLog2 Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "sqrt"
      -> IR.ESqrt Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "as_vec"
      -> IR.EAsVec Sym.nilSym (map convFuncArg args)
    | (strOfIdent id) == "as_ivec"
      -> IR.EAsIVec Sym.nilSym (map convFuncArg args)
    | otherwise
      -> IR.EFunc Sym.nilSym (convIdent id) (map convFuncArg args)
  _ -> error $ "[IR] Unknown expression: " ++ show e

  where

    strOfIdent :: AST.Ident -> String
    strOfIdent id = stringFromIdent $ convIdent id
  

convMDec :: AST.MDec -> IR.Ident -> IR.MDec
convMDec m structId = case m of
  AST.MDecl ty id -> IR.MDecl (convType ty) (convIdent id) structId


convStruc :: AST.Struc -> IR.Struc
convStruc s = case s of
  AST.Struct id mdecs -> Struct (convIdent id) (map (\m -> convMDec m (convIdent id)) mdecs)


stringFromIdent :: Ident -> String
stringFromIdent (IR.Ident str) = str


getFuncType :: IR.Func -> T.Typ 
getFuncType f = case f of
    IR.Fun _ t _ _ _ -> convTypeMUDA t

getFuncName :: IR.Func -> String
getFuncName f = case f of
    IR.Fun _ _ id _ _ -> stringFromIdent id

convDeclInitExpr :: AST.DecInitExp -> IR.DecInitExp
convDeclInitExpr initExps = case initExps of
  AST.DExp exp -> IR.DExp Sym.nilSym (convExpr exp) 

-- TODO parse Exp
convDeclInit :: AST.DecInit -> IR.DecInit
convDeclInit decInit = case decInit of
  AST.DeclInit id initExps -> IR.DeclInit (convIdent id) (map convDeclInitExpr initExps)

expandSDecl :: Typ -> [AST.DecInit] -> [IR.Stm]
expandSDecl ty []          = []
expandSDecl ty (dec:decls) = (IR.SDecl Sym.nilSym ty (convDeclInit dec)) : expandSDecl ty decls

convStms :: AST.Stm -> [IR.Stm]
convStms s = case s of
  AST.SDecl   ty declinits     -> expandSDecl (convType ty) declinits
  AST.SAssign id exp           -> [IR.SAssign Sym.nilSym (convIdent id) (convExpr exp)]
  AST.SAssignWithField id fields exp -> [IR.SAssignWithField Sym.nilSym (convIdent id) (map convField fields) (convExpr exp)]
  AST.SAssignWithArray id idxExp exp -> [IR.SAssignWithArray Sym.nilSym (convIdent id) (convExpr idxExp) (convExpr exp)]
  AST.SBlock  stms             -> [IR.SBlock (concatMap convStms stms)]
  AST.SWhile  exp stm          -> [IR.SWhile (convExpr exp) (convStms stm)]
  AST.SIf     exp stms0 stms1  -> [IR.SIf (convExpr exp) (concatMap convStms stms0) (concatMap convStms stms1)]
  AST.SReturnVoid              -> [IR.SReturnVoid]
  AST.SReturn exp              -> [IR.SReturn (convExpr exp)]
  AST.SExp exp                 -> [IR.SExp (convExpr exp)]
  _                            -> error $ "TODO: convStms: " ++ show s 

-- stms            -> [IR.SReturn (concatMap convStms stms)]



convFuncSpec :: AST.FuncSpec -> IR.FuncSpec
convFuncSpec spec = case spec of
  AST.InlineFuncSpec       -> IR.InlineFuncSpec
  AST.ForceInlineFuncSpec  -> IR.AlwaysInlineFuncSpec
  AST.AlwaysInlineFuncSpec -> IR.AlwaysInlineFuncSpec
  AST.StaticFuncSpec       -> IR.StaticFuncSpec

convFunc :: AST.Func -> IR.Func
convFunc f = case f of 
  AST.Fun funcspecs ty id formaldecs stms
    -> let t = convTypeMUDA $ convType ty in
       let ident = convIdent id in
       IR.Fun (map convFuncSpec funcspecs)
              (convType ty)
              (convIdent id)
              (map convFormalDec formaldecs)
              (concatMap convStms stms)

getFormalDecType :: IR.FormalDec -> T.Typ 
getFormalDecType d = case d of
  IR.FormalDecl _ qs t id -> convTypeMUDA t

getFormalDecName :: IR.FormalDec -> String
getFormalDecName d = case d of
  IR.FormalDecl _ qs t id -> stringFromIdent id

getFormalDecQual :: IR.FormalDec -> T.Qual
getFormalDecQual d = case d of
  IR.FormalDecl _ []     t id -> T.InputQual
  IR.FormalDecl _ [q]    t id -> convQualMUDA q
  IR.FormalDecl _ (q:qs) t id -> convQualMUDA q     -- take head's one only.

convFormalDec :: AST.FormalDec -> IR.FormalDec
convFormalDec f = case f of
  AST.FormalDecl [] ty id ->

    dec

    where dec = IR.FormalDecl Sym.nilSym
                              [IR.InputQual]
                              (convType ty)
                              (convIdent id)

  AST.FormalDecl quals ty id ->

    dec

    where dec = IR.FormalDecl Sym.nilSym
                              (map convQual quals)
                              (convType ty)
                              (convIdent id)



convQual :: AST.Qual -> IR.Qual
convQual q = case q of
  AST.InputQual  -> IR.InputQual
  AST.OutputQual -> IR.OutputQual
  AST.InOutQual  -> IR.InOutQual
  AST.ArrayQual  -> IR.ArrayQual


convProg :: AST.Prog -> IR.Prog
convProg ast = case ast of
--  AST.Program s f -> Program (mapSeq convStruc s) (mapSeq convFunc f)
  AST.Program s f -> Program (map convStruc s) (map convFunc f)


{-
--
-- Handling swizzle
--

--
-- Swizzle pattern. 
--
-- length(str) must be 1 or 4.
--
-- each letter should have oneof "xyzwrgba"
--
isSwizzle :: String -> Bool
isSwizzle str 
  | ((length str) == 1) /= True && ((length str) /= 4) == True = False 
  | otherwise = if length (filter (\x -> x == False) (map isSwizzleLetter str)) > 0 then False else True
    
  where
    isSwizzleLetter :: Char -> Bool
    isSwizzleLetter c 
      | c == 'x' || c == 'y' || c == 'z' || c == 'w' = True
      | c == 'r' || c == 'g' || c == 'b' || c == 'a' = True
      | otherwise                                    = False
      


--
-- If length str == 1, replicate swizzle letter 4 times.
-- e.g. val.x -> val.xxxx
--
swizzleIndexFromString :: String -> SwizzleIndex
swizzleIndexFromString str 
  | (length str) == 1 = swizzleIndexFromString $ replicate 4 (str !! 0)
  | otherwise =
    map toIndex str

    where

      toIndex :: Char -> Int
      toIndex c = case c of
        'x' -> 0
        'y' -> 1
        'z' -> 2
        'w' -> 3
        'r' -> 0
        'g' -> 1
        'b' -> 2
        'a' -> 3
        _  -> 0
-}
    

parseFloatingPoint :: GenParser Char st Double
parseFloatingPoint =

  do sign <- option 1 (do s <- oneOf "+-"
                          return $ if s == '-' then -1.0 else 1.0)
     x    <- P.float $ P.makeTokenParser emptyDef
     return $ sign * x


readFloatingPoint :: String -> Double
readFloatingPoint input = case parse parseFloatingPoint "" input of
  Left err  -> error "parse float err."
  Right val -> val

-- vim: set sw=2 ts=2 expandtab: 

