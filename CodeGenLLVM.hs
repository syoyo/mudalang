-------------------------------------------------------------------------------
---- |
---- Module      :  CodeGenLLVM
---- Copyright   :  (c) Syoyo Fujita
---- License     :  BSD-style
----
---- Maintainer  :  syoyo@lighttransport.com
---- Stability   :  experimental
---- Portability :  GHC 7.6
----
---- CodeGenLLVM :  Code generator for LLVM IR(ascii format).
----                TODO: Use Template Haskell?
----
-------------------------------------------------------------------------------
module CodeGenLLVM where

import Debug.Trace
import Numeric
import Foreign
import Foreign.Marshal.Alloc
import Foreign.C.Types
import System.IO.Unsafe         -- A magical module ;-)

import Data.Char
import qualified IR
import qualified Sym
import qualified TypeMUDA as T

-- pretty-printer grabbed from PrintMUDA.hs generated by the BNF converter
-- with small modification.

-- the top-level printing method
printTree :: (CodeGenLLVM a) => a -> String
printTree tree = headerString ++ (render $ prt tree)

printIntrinsicHeader :: String
printIntrinsicHeader = headerString

type Doc           = [ShowS] -> [ShowS]

type Register      = String
type Register4     = (Register, Register, Register, Register)
type TypedRegister = (Register, T.Typ)

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> new i . showChar '{' . new (i+1) . rend (i+1) ts
    -- "} else {" :ts -> trace "else" $ new (i-1) . showString "} else {" . new i . rend i ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    t  : "}" :ts -> showString t . new (i-1) . showString "}" . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    --";"      :ts -> showChar ';' . new i . rend i ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    "\n"     :ts -> new i . rend i ts
    t  : "," :ts -> showString t . space "," . rend i ts
    t  : ")" :ts -> showString t . showString ") " . rend i ts
    t  : "]" :ts -> showString t . showChar ']' . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  --new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile isSpace
  new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile (\x -> x == ' ')
  -- new2 ii  = trace "new2" $ showChar '\n'
  space t = showString t . (\s -> if null s then "" else (' ':s))

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

instance CodeGenLLVM Char where
  prt s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

doubleAsULLong :: Ptr CDouble -> IO CULLong
doubleAsULLong p = do
  ull <- peek (castPtr p)
  return ull

floatAsUInt :: Ptr CFloat -> IO CUInt
floatAsUInt p = do
  ui <- peek (castPtr p)
  return ui

bitcastFloatToUInt :: CFloat -> CUInt
bitcastFloatToUInt f = System.IO.Unsafe.unsafePerformIO $ do
  r <- with f floatAsUInt
  return r

bitcastDoubleToULLong :: CDouble -> CULLong
bitcastDoubleToULLong d = System.IO.Unsafe.unsafePerformIO $ do
  r <- with d doubleAsULLong
  return r

showHexReplOfFloat  f = "0x" ++ showHex (bitcastFloatToUInt    f) ""
showHexReplOfDouble d = "0x" ++ showHex (bitcastDoubleToULLong d) ""

doubleToCFloat :: Double -> CFloat
doubleToCFloat d = realToFrac d

cfloatToCDouble :: CFloat -> CDouble
cfloatToCDouble f = realToFrac f

--
-- CodeGenLLVM class
--

class CodeGenLLVM a where
  prt :: a -> Doc
  prtList :: [a] -> Doc
  prtList = concatD . map prt


instance CodeGenLLVM a => CodeGenLLVM [a] where
  prt = prtList


regNameOfSymFromExp :: IR.Exp -> Register
regNameOfSymFromExp exp = regNameOfSym (IR.getSymFromExp exp)

regNameOfSym :: Sym.Sym -> Register
regNameOfSym sym = "%" ++ Sym.getName sym

--
-- Create a dummy symbol to get a unique name.
--
mkLabel :: String -> Register
mkLabel str = 
  str ++ "_" ++ (Sym.getName (Sym.genSym T.Vec [] Sym.KindVariable))


mkTempReg :: Sym.Sym -> Register
mkTempReg sym = 
  regNameOfSym (Sym.genSym (Sym.getType sym) (Sym.getQuals sym) (Sym.getKind sym))

mkTempRegFromTy :: T.Typ -> Register
mkTempRegFromTy ty =
  regNameOfSym (Sym.genSym ty [] Sym.KindVariable)


mkTempSym :: Sym.Sym -> Sym.Sym
mkTempSym sym = Sym.genSym (Sym.getType sym) (Sym.getQuals sym) (Sym.getKind sym)


convTy :: IR.Typ -> T.Typ
convTy (IR.TName (IR.Ident id)) = T.typeFromString id


isLeafExp :: IR.Exp -> Bool 
isLeafExp exp = case exp of
  (IR.EFloat _ _) -> True
  (IR.EInt   _ _) -> True
  (IR.EIdent _ _) -> True
  _               -> False

--
-- %ret = "op" %r0 %r1 
--
--
prtBinOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtBinOp opStr sym e0 e1 = concatD 
  [ prt e0
  , prt e1
  , prtSym sym
  , docStr " = "
  , docStr opStr
  , prtTy (Sym.getType sym)
  , prtSymOfExp e0
  , docStr ", "
  , prtSymOfExp e1
  , docStr " "
  , docStr ";"
  ]

--
-- LLVM's fcmp instruction does not support vector type for its operand.
-- Compare each element independently, then pack those result back to vector.
--
prtCmpOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtCmpOp opStr sym exp0 exp1 = concatD 
  [ prt exp0
  , prt exp1

  --

  , prtExtractElement expReg00 expReg0 0
  , prtExtractElement expReg01 expReg0 1
  , prtExtractElement expReg02 expReg0 2
  , prtExtractElement expReg03 expReg0 3

  --

  , prtExtractElement expReg10 expReg1 0
  , prtExtractElement expReg11 expReg1 1
  , prtExtractElement expReg12 expReg1 2
  , prtExtractElement expReg13 expReg1 3

  --

  , prtCompare retReg0 expReg00 expReg10
  , prtCompare retReg1 expReg01 expReg11
  , prtCompare retReg2 expReg02 expReg12
  , prtCompare retReg3 expReg03 expReg13

  --

  , prtExt extReg0 retReg0
  , prtExt extReg1 retReg1
  , prtExt extReg2 retReg2
  , prtExt extReg3 retReg3

  -- bitcast

  , prtBitcast (fReg0, T.F) (extReg0, T.I)  
  , prtBitcast (fReg1, T.F) (extReg1, T.I)  
  , prtBitcast (fReg2, T.F) (extReg2, T.I)  
  , prtBitcast (fReg3, T.F) (extReg3, T.I)  

  -- pack

  , prtPackElement (regNameOfSym sym) (fReg0, fReg1, fReg2, fReg3) T.F T.Vec

  , docStr ";"
  ]

  where

    expReg0 = regNameOfSym (IR.getSymFromExp exp0)
    expReg1 = regNameOfSym (IR.getSymFromExp exp1)

    extReg0 = mkTempRegFromTy T.I
    extReg1 = mkTempRegFromTy T.I
    extReg2 = mkTempRegFromTy T.I
    extReg3 = mkTempRegFromTy T.I

    fReg0   = mkTempRegFromTy T.F
    fReg1   = mkTempRegFromTy T.F
    fReg2   = mkTempRegFromTy T.F
    fReg3   = mkTempRegFromTy T.F

    retReg0 = mkTempRegFromTy T.F
    retReg1 = mkTempRegFromTy T.F
    retReg2 = mkTempRegFromTy T.F
    retReg3 = mkTempRegFromTy T.F

    expReg00 = mkTempRegFromTy T.F
    expReg01 = mkTempRegFromTy T.F
    expReg02 = mkTempRegFromTy T.F
    expReg03 = mkTempRegFromTy T.F

    expReg10 = mkTempRegFromTy T.F
    expReg11 = mkTempRegFromTy T.F
    expReg12 = mkTempRegFromTy T.F
    expReg13 = mkTempRegFromTy T.F

    prtCompare :: Register -> Register -> Register -> Doc
    prtCompare outReg reg0 reg1 = concatD

      [ docStr outReg
      , docStr "="
      , docStr "fcmp"
      , docStr opStr
      , prtTy T.F
      , docStr reg0
      , docStr ", "
      , docStr reg1
      , docStr ";"
      ]

    -- extend i1 to i32
    prtExt :: Register -> Register -> Doc
    prtExt dstReg srcReg = concatD

      [ docStr dstReg
      , docStr "="
      , docStr "sext"
      , docStr "i1"
      , docStr srcReg
      , docStr "to"
      , docStr "i32"
      , docStr ";"
      ]

    tmpReg0 = mkTempRegFromTy T.F
    tmpReg1 = mkTempRegFromTy T.F
    tmpReg2 = mkTempRegFromTy T.F
    tmpReg3 = mkTempRegFromTy T.F

--
-- e1 for shift op should be EItoIV (EInt val)
--
prtShiftOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtShiftOp opStr sym e0 (IR.EItoIV _ intExp) = concatD
  [ prt e0
  , prt intExp
  , prtSymConstDef sym
  , docStr " = "
  , docStr ("(__m128)" ++ opStr ++ "((__m128i)")
  , prtSymOfExp e0
  , docStr ", "
  , prtSymOfExp intExp
  , docStr ")" 
  , docStr ";"
  ]

--
-- %dst = bitcast srcType %src to dstType
--
prtBitcast :: TypedRegister -> TypedRegister -> Doc
prtBitcast (dstReg, dstTy) (srcReg, srcTy) = concatD
  [ docStr dstReg
  , docStr "="
  , docStr "bitcast"
  , prtTy srcTy
  , docStr srcReg
  , docStr "to"
  , prtTy dstTy
  , docStr ";"
  ]


--
-- Bit truncation instruction
--
prtTrunc :: TypedRegister -> TypedRegister -> Doc
prtTrunc (dstReg, dstTy) (srcReg, srcTy) = concatD

  [ docStr dstReg
  , docStr "="
  , docStr "trunc"
  , prtTy srcTy
  , docStr dstReg
  , docStr "to"
  , prtTy dstTy
  , docStr ";"
  ]

  


--
-- Logic op in LLVM IR accepts only integer expression.
-- If e0 and e1 are float expression, convert it to integer expression
-- by using "bitcast" instruction.
--
prtLogicOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtLogicOp opStr sym e0 e1 = concatD
  [ prt e0
  , prt e1

  , if (needsBitcast srcTy) then
    concatD [ prtBitcast (regExp0, dstTy) (srcReg0, srcTy) 
            , prtBitcast (regExp1, dstTy) (srcReg1, srcTy) 
            ]
    else 
    concatD []

  , docStr retReg
  , docStr "=" 
  , docStr opStr
  , prtTy dstTy
  , docStr regExp0
  , docStr ", "
  , docStr regExp1
  , docStr ";"

  -- %ret = bitcast dstTy %reg to srcTy

  , if (needsBitcast srcTy) then
    concatD [ prtBitcast ( (regNameOfSym sym), srcTy) (retReg, dstTy) ]
    else
    concatD []

  ]

  where
    
    symExp0 = (IR.getSymFromExp e0)
    symExp1 = (IR.getSymFromExp e1)

    tempRegExp0 = mkTempReg (IR.getSymFromExp e0)
    tempRegExp1 = mkTempReg (IR.getSymFromExp e1)

    srcTy = Sym.getType symExp0
    dstTy = case (getBitcastType (Sym.getType symExp0)) of
      Just newTy -> newTy
      Nothing    -> srcTy

    retReg = if (needsBitcast srcTy)
      then mkTempRegFromTy dstTy 
      else regNameOfSym sym

    srcReg0 = regNameOfSym symExp0
    srcReg1 = regNameOfSym symExp1

    (regExp0, regExp1) = case (getBitcastType (Sym.getType symExp0)) of
      Just newTy -> (mkTempRegFromTy newTy, mkTempRegFromTy newTy)
      Nothing    -> (srcReg0, srcReg1)

    needsBitcast :: T.Typ -> Bool
    needsBitcast ty
      | ty == T.F || ty == T.Vec = True
      | otherwise                = False
    
    getBitcastType :: T.Typ -> Maybe T.Typ
    getBitcastType ty
      | ty == T.F     = Just T.I
      | ty == T.Vec   = Just T.IVec
      | otherwise     = Nothing
  

--
-- Not is mapped to xor %exp, -1
--
prtNotOp sym exp = concatD
  [ prt exp
  , prtSym sym
  , docStr "="
  , docStr "xor"
  , prtSymOfExp exp
  , docStr ","
  , docStr "-1"
  , docStr ";"
  ]


prtFuncArgSyms :: [IR.Exp] -> Doc
prtFuncArgSyms []     = concatD []
prtFuncArgSyms [e]    = concatD [prtSymOfExp e]
prtFuncArgSyms (e:es) = concatD [prtSymOfExp e, docStr ",", prtFuncArgSyms es]

prtFuncArgSymRefs :: [IR.Exp] -> Doc
prtFuncArgSymRefs []     = concatD []
prtFuncArgSymRefs [e]    = concatD [docStr "&(", prtSymOfExp e, docStr ")"]
prtFuncArgSymRefs (e:es) = concatD [docStr "&(", prtSymOfExp e, docStr "),", prtFuncArgSymRefs es]

--
-- vtof is mapped to extractelement
--
prtVtoF :: Sym.Sym -> IR.Exp -> Doc
prtVtoF sym exp = prtExtractElement (regNameOfSym sym) 
                                    (regNameOfSym (IR.getSymFromExp exp))
                                    0  -- preffered slot


--
-- emit code such like,
--
--   float tmp[4];
--   _mm_storeu_ps(tmp, v);
--
prtVtoArray :: T.Typ -> Sym.Sym -> String -> IR.Exp -> Doc
prtVtoArray ty sym tmpStr exp =
  concatD [ docStr $ strOfType ty
          , docStr $ tmpStr ++ "[4]"
          , docStr ";"
          , docStr "_mm_storeu_ps"
          , docStr "("
          , docStr tmpStr
          , docStr ","
          , prtSymOfExp exp
          , docStr ")"
          , docStr ";"
          ]


--
-- If symbol is a function argument emit below code.
--
--   %tmp = alloca
--   store %sym %tmp
--   load %reg %tmp
--
-- Otherwise,
--
--   load %reg %sym
--
--
prtLoad :: Sym.Sym -> Register -> Doc
prtLoad sym regName =
  if (Sym.getKind sym) == Sym.KindFormalVariable then

    concatD [

            -- alloc

              prtSymDef tempSym
            
            -- store

            , docStr "store"
            , prtTy (Sym.getType sym)  
            , prtSym sym
            , docStr ","
            , prtSymRef tempSym
            , docStr ";"

            -- load

            , docStr regName
            , docStr "="
            , docStr "load"
            , prtSymRef tempSym
            , docStr ";"
            ]

  else

    concatD [ docStr regName
            , docStr "="
            , docStr "load"
            , prtSymRef sym
            , docStr ";"
            ]

  where

    tempSym = mkTempSym sym

--
-- If symbol is a function argument emit below code.
--
--   %addr   = alloca type*
--   store type* %sym, type** %addr
--   %ptr    = load type** %addr
--   %arridx = getelementptr type* %ptr, i32 idx
--   %r      = load type* %arridx
--
-- Otherwise,
--
--   load %reg %sym
--
--
prtLoadPtr :: Sym.Sym -> Register -> IR.Exp -> Doc
prtLoadPtr sym regName idxExp =
  if (Sym.getKind sym) == Sym.KindFormalVariable then

    concatD [

            -- alloc

              prtSymDefPtr tempSym
            
            -- store

            , docStr "store"
            , prtTyRef (Sym.getType sym)  
            , prtSym sym
            , docStr ","
            , prtSymRefRef tempSym
            , docStr ";"

            -- getidx

            , docStr idxReg
            , docStr "="
            , docStr "getelementptr"
            , prtTyRef (Sym.getType sym)
            , docStr "i32"
            , prtSym (IR.getSymFromExp idxExp)

            -- load

            , docStr regName
            , docStr "="
            , docStr "load"
            , prtTyRef (Sym.getType sym)
            , docStr idxReg
            , docStr ";"
            ]


  else

    concatD [ docStr regName
            , docStr "="
            , docStr "load"
            , prtSymRef sym
            , docStr ";"
            ]

  where

    tempSym = mkTempSym sym
    idxReg  = mkTempRegFromTy T.I


prtStoreLoad :: Sym.Sym -> String -> Doc
prtStoreLoad sym regName =

    concatD [

            -- alloc

              prtSymDef tempSym
            
            -- store

            , docStr "store"
            , prtTy (Sym.getType sym)  
            , prtSym sym
            , docStr ","
            , prtSymRef tempSym
            , docStr ";"

            -- load

            , docStr regName
            , docStr "="
            , docStr "load"
            , prtSymRef tempSym
            , docStr ";"
            ]

  where

    tempSym = mkTempSym sym

--
-- Pack 4 scalars to one vector using "insertelement"
--
prtPackElement :: Register -> Register4 -> T.Typ -> T.Typ -> Doc
prtPackElement dstReg (reg0, reg1, reg2, reg3) scalarT vectorT = concatD

  [ prtInsertElement tmpReg0 "undef" reg0 0 scalarT vectorT
  , prtInsertElement tmpReg1 tmpReg0 reg1 1 scalarT vectorT
  , prtInsertElement tmpReg2 tmpReg1 reg2 2 scalarT vectorT
  , prtInsertElement dstReg  tmpReg2 reg3 3 scalarT vectorT
  ]

  where

    tmpReg0 = mkTempRegFromTy vectorT
    tmpReg1 = mkTempRegFromTy vectorT
    tmpReg2 = mkTempRegFromTy vectorT


--
-- Emit "insertelement" instruction
--
prtInsertElement :: Register -> Register -> Register -> Int -> T.Typ -> T.Typ -> Doc
prtInsertElement tmpReg reg expReg slot scalarTy vectorTy =
  concatD [ docStr tmpReg
          , docStr "="
          , docStr "insertelement"
          , prtTy vectorTy
          , docStr reg
          , docStr ","
          , prtTy scalarTy
          , docStr expReg
          , docStr ","
          , docStr ("i32 " ++ show slot)
          , docStr ";"
          ]


--
-- Emit "extractelement" instruction
--
prtExtractElement :: Register -> Register -> Int -> Doc
prtExtractElement tmpReg reg slot =
  concatD [ docStr tmpReg
          , docStr "="
          , docStr "extractelement"
          , prtTy T.Vec
          , docStr reg
          , docStr ","
          , docStr ("i32 " ++ show slot)
          , docStr ";"
          ]

--
-- Emit "shufflevector" instruction
--
prtShuffleVector :: Register -> T.Typ -> Register -> Register -> [Integer] -> Doc
prtShuffleVector retReg ty reg0 reg1 slots =
  concatD [ docStr retReg
          , docStr "="
          , docStr "shufflevector"
          , prtTy ty
          , docStr reg0
          , docStr ","
          , prtTy ty
          , docStr reg1
          , docStr ","
          , prtTy T.IVec
          , docStr "<"
          , docStr ("i32 " ++ show (slots !! 0))
          , docStr ","
          , docStr ("i32 " ++ show (slots !! 1))
          , docStr ","
          , docStr ("i32 " ++ show (slots !! 2))
          , docStr ","
          , docStr ("i32 " ++ show (slots !! 3))
          , docStr ">"
          , docStr ";"
          ]

--
-- Use "insertelement" intrinsic.
--
--   %r    = alloca
--   %tmp  = load %x
--   %tmp0 = insertelement undef %tmp 0
--   %tmp1 = insertelement %tmp0 %tmp 1
--   %tmp2 = insertelement %tmp1 %tmp 2
--   %tmp3 = insertelement %tmp2 %tmp 3
--   store %tmp3 %r
--
-- TODO: If the given expression is immediate floating point value,
--       we could rewrite above with just one "store" intrinsic.
--
--         store <1.0, 1.0, 1.0, 1.0>, %r
--
prtFtoV :: Sym.Sym -> IR.Exp -> Doc
prtFtoV sym exp =

  concatD [ prtPackElement (regNameOfSym sym) (regExp, regExp, regExp, regExp) T.F T.Vec
          , docStr "\n"
          ]


  where

    symExp :: Sym.Sym
    symExp = IR.getSymFromExp exp

    regExp :: String
    regExp = regNameOfSym (IR.getSymFromExp exp)


prtItoV :: Sym.Sym -> IR.Exp -> Doc
prtItoV sym exp =

  concatD [ docStr fpReg
          , docStr "="
          , docStr "sitofp"
          , prtTy T.I
          , docStr regExp
          , docStr "to"
          , prtTy T.F
          , docStr ";"

          , prtPackElement (regNameOfSym sym) (fpReg, fpReg, fpReg, fpReg) T.F T.Vec
          , docStr "\n"
          ]


  where

    symExp :: Sym.Sym
    symExp = IR.getSymFromExp exp

    regExp :: String
    regExp = regNameOfSym (IR.getSymFromExp exp)

    fpReg  = mkTempRegFromTy T.F

prtFtoI :: Sym.Sym -> IR.Exp -> Doc
prtFtoI sym exp =

  concatD [ prtSym sym
          , docStr "="
          , docStr "fptosi"
          , prtTy T.Vec
          , prtSymOfExp exp
          , docStr "to"
          , prtTy T.IVec
          , docStr ";"
          ]

--
-- Use "insertelement" intrinsic.
--
-- "exp" are vector type, thus first convert it to scalar by
-- "extractelement"
--
--   %reg0 = extractelement %exp0, i32 0
--   %reg1 = extractelement %exp1, i32 0
--   %reg2 = extractelement %exp2, i32 0
--   %reg3 = extractelement %exp3, i32 0
--
--   %tmp0 = insertelement undef %reg0 0
--   %tmp1 = insertelement %tmp0 %reg1 1
--   %tmp2 = insertelement %tmp1 %reg2 2
--   %tmp3 = insertelement %tmp2 %reg3 3
--
--
prtFtoV4 :: Sym.Sym -> (IR.Exp, IR.Exp, IR.Exp, IR.Exp) -> Doc
prtFtoV4 sym (exp0, exp1, exp2, exp3) =

  concatD [ prtExtractElement tmpExpReg0         expReg0 0
          , prtExtractElement tmpExpReg1         expReg1 0
          , prtExtractElement tmpExpReg2         expReg2 0
          , prtExtractElement tmpExpReg3         expReg3 0

          , prtPackElement (regNameOfSym sym) (tmpExpReg0, tmpExpReg1, tmpExpReg2, tmpExpReg3) T.F T.Vec
          , docStr "\n"
          ]


  where

    expReg0 = regNameOfSym (IR.getSymFromExp exp0)
    expReg1 = regNameOfSym (IR.getSymFromExp exp1)
    expReg2 = regNameOfSym (IR.getSymFromExp exp2)
    expReg3 = regNameOfSym (IR.getSymFromExp exp3)

    tmpExpReg0 = mkTempRegFromTy T.Vec
    tmpExpReg1 = mkTempRegFromTy T.Vec
    tmpExpReg2 = mkTempRegFromTy T.Vec
    tmpExpReg3 = mkTempRegFromTy T.Vec

--
-- int -> ivec
--
prtItoIV :: Sym.Sym -> IR.Exp -> Doc
prtItoIV sym exp =

  concatD [ prtPackElement (regNameOfSym sym) (regExp, regExp, regExp, regExp) T.I T.IVec
          , docStr "\n"
          ]


  where

    symExp :: Sym.Sym
    symExp = IR.getSymFromExp exp

    regExp :: String
    regExp = regNameOfSym (IR.getSymFromExp exp)

instance CodeGenLLVM IR.Exp where
  prt e = case e of

    -- access to variable
    --
    IR.ELoad sym (IR.EIdent idSym id) -> concatD

      [ prtSym sym
      , docStr "="
      , docStr "load"
      , prtSymMemRef idSym
      , docStr ";"
      , docStr "\n"
      ]


    IR.ELoad sym exp     -> concatD

       [ prt exp
       , prtSym sym
       , docStr "="
       , docStr "load"
       , prtSymRef (IR.getSymFromExp exp)
       , docStr ";"
       , docStr "\n"
       ]

    -- IR.EIdent sym id     -> concatD [prtSym sym]

    IR.EFloat sym val    -> concatD

       [ prtSymDef sym
       , docStr "store"
       , docStr "float"
       --
       -- LLVM IR requires 64bit hex value for 32bit floating point value.
       -- i.e., hex((double)(float)val)
       --
       , docStr $ showHexReplOfDouble $ cfloatToCDouble $ doubleToCFloat val
       , docStr ","
       , prtSymRef sym
       , docStr ";"
       , docStr "\n"
       ]

    IR.EInt sym val      -> concatD

       [ prtSymConstDef sym
       , docStr "="
       , docStr $ show val
       , docStr ";"
       , docStr "\n"
       ]

    IR.EIdent sym id     -> concatD []    -- Output nothing

    IR.EFtoV  sym exp    -> concatD [ prt exp
                                    , prtFtoV sym exp
                                    ]

    IR.EItoIV sym exp    -> concatD [ prt exp
                                    , prtItoIV sym exp
                                    ]

    IR.EVtoF  sym exp    -> concatD [ prt exp
                                    , prtVtoF sym exp
                                    ]
                                    

    --
    -- bin op
    -- TODO: parameterize bin op str
    --
    IR.EAnd   sym e0 e1       -> prtLogicOp "and"    sym e0 e1
    IR.EOr    sym e0 e1       -> prtLogicOp "or"     sym e0 e1
    IR.EXor   sym e0 e1       -> prtLogicOp "xor"    sym e0 e1
    IR.ENot   sym e0 e1       -> prtLogicOp "todo"   sym e0 e1 -- TODO
    IR.EEq    sym e0 e1       -> prtCmpOp   "oeq"    sym e0 e1
    IR.ENeq   sym e0 e1       -> prtCmpOp   "one"    sym e0 e1
    IR.EGt    sym e0 e1       -> prtCmpOp   "ogt"    sym e0 e1
    IR.EGte   sym e0 e1       -> prtCmpOp   "oge"    sym e0 e1
    IR.ELt    sym e0 e1       -> prtCmpOp   "olt"    sym e0 e1
    IR.ELte   sym e0 e1       -> prtCmpOp   "ole"    sym e0 e1
    IR.ESlElemWise sym e0 e1  -> prtShiftOp "slli_epi32"  sym e0 e1
    IR.ESrElemWise sym e0 e1  -> prtShiftOp "srli_epi32"  sym e0 e1
    IR.ESlQWord sym e0 e1     -> prtShiftOp "slli_si128"  sym e0 e1
    IR.ESrQWord sym e0 e1     -> prtShiftOp "slri_si128"  sym e0 e1
    IR.EAdd   sym e0 e1       -> prtBinOp   "add"    sym e0 e1
    IR.ESub   sym e0 e1       -> prtBinOp   "sub"    sym e0 e1
    IR.EMul   sym e0 e1       -> prtBinOp   "mul"    sym e0 e1
    IR.EDiv   sym e0 e1       -> prtBinOp   "fdiv"   sym e0 e1

    --
    -- TODO: LLVM does not provide reciprocal estimate or
    --       reciprocal square estimate instruction.
    --       Define LLVM intrinsics?
    --       (Though it may depends on some CPU architecture)
    -- 
    IR.EDivApprox   sym e0 e1  -> prtBinOp "fdiv" sym e0 e1

    --
    -- TODO: Do optimization when constant value is provided as its array index 
    --       e.g. EArray a (EInt 3) -> [rewrite as] -> a[3]
    --
    -- %tmp = getelementptr type* %exp, i32 idx 
    --
    --
    IR.EArray sym exp idxExp
        -> concatD  [ prt exp
                    , prt idxExp
                    , docStr "; EArray"

                    --
                    
                    , prtLoadPtr sym (regNameOfSymFromExp exp) idxExp

                    -- 

                    ]

                  

    IR.EFunc  sym id exps 
      | (Sym.getType sym) == T.Void
        -> concatD [concatD $ map prt exps,
                    docStr (IR.stringFromIdent id),
                    docStr "(",
                    prtFuncArgSymRefs exps,
                    docStr ")",
                    docStr ";"]
      | otherwise
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    docStr (IR.stringFromIdent id),
                    docStr "(",
                    prtFuncArgSymRefs exps,
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- TODO: Use same code gen for intrinsic functions.
    --

    IR.EVecInit  sym exps 
      | (length exps) == 1
        -- sym of exp is already vectorized, thus just emit assign.
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    prtFuncArgSyms exps,
                    docStr ";"
                   ]

      --
      -- TODO: support for ivec type.
      --
      | (length exps) == 4
        -> concatD [concatD $ map prt exps,
                    prtFtoV4 sym (exps !! 0, exps !! 1, exps !! 2, exps !! 3)
                   ]
      | otherwise
        -> error ("vec() with invalid number of args:" ++ (show $ length exps))

    IR.ESel     sym exps 
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    docStr "muda_sel_ps",
                    docStr "(",
                    prtFuncArgSyms exps,
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- extract(exp, index)
    -- exps[0] => exp
    -- exps[1] => index
    --
    IR.EExtract     sym exps 
        -> concatD [ prt $ exps !! 0      -- expand first elem only
                   , prtShuffleVector symReg symTy expReg expReg
                                      (replicate 4 (getConstantInt (exps !! 1)))
                   , docStr ";"
                   ]

                   where

                     symReg = regNameOfSym sym
                     symTy  = Sym.getType sym
                     expReg = regNameOfSym (IR.getSymFromExp (exps !! 0))

    --
    -- bit
    --
    -- %tmp  = alloca i32
    -- store i32 val, i32* %tmp
    -- %conv = bitcast i32* %tmp to float*
    -- %fval = load float* %conv
    -- %ret  = ftov(%fval)
    --
    IR.EBtoV sym (IR.EInt sym' val) 
        ->  concatD

            [ docStr convMemReg
            , docStr "="
            , docStr "alloca"
            , prtTy T.I
            , docStr ";"
          
            --

            , docStr "store"
            , docStr "i32"
            , docStr $ show val
            , docStr ","
            , prtTyRef T.I
            , docStr convMemReg
            , docStr ";"

            --

            , docStr convReg
            , docStr "="
            , docStr "bitcast"
            , prtTyRef T.I
            , docStr convMemReg
            , docStr "to"
            , prtTyRef T.F
            , docStr ";"

            -- 

            , docStr fvalReg
            , docStr "="
            , docStr "load"
            , prtTyRef T.F
            , docStr convReg    -- Be sure that convReg, not convMemReg!
            , docStr ";"

            , prtPackElement (regNameOfSym sym) (fvalReg, fvalReg, fvalReg, fvalReg) T.F T.Vec

            ]

            where 

              convMemReg  = mkTempRegFromTy T.I
              convReg     = mkTempRegFromTy T.F

              fvalReg     = mkTempRegFromTy T.F

     

    --
    -- ret:vec = bit(val:ivec)
    --
    IR.EBtoV sym exp -> concatD

      [ prt exp
      , prtSym sym
      , docStr "="
      , docStr "bitcast"
      , docStr "<4xi32>"
      , prtSymOfExp exp
      , docStr "<4xfloat>"
      , docStr ";"
      ]

    --
    -- itof
    -- Mapped to itov
    --
    IR.EItoF sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtItoV sym (exps !! 0)
                   ]

    --
    -- ftoi(x).
    -- float to integer conversion with truncation.
    -- Note that returned value is still a vector type, not integer vector type.
    --
    IR.EFtoI sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtFtoI sym (exps !! 0)
                   ]

    --
    -- 1/sqrt(x). Use approximate rsqrt().
    -- TODO: Add one round of Newton-Raphson for finer accuracy?
    --
    IR.ERsqrt sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "_mm_rsqrt_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- frac(x).
    -- Mapped to muda_frac_ps(x).
    -- 
    --
    IR.EFrac sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "_mm_sub_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ", "
                   , docStr "muda_ceil_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- ceil(x).
    -- Mapped to muda_ceil_ps().
    -- 
    -- NOTE: SSE4 has _mm_ceil_ps() intrinsic function?.
    --
    IR.ECeil sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "muda_ceil_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- floor(x).
    -- Mapped to muda_floor_ps().
    -- 
    -- NOTE: SSE4 has _mm_floor_ps() intrinsic function?.
    --
    IR.EFloor sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "muda_floor_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]


    --
    -- trunc(x).
    -- Mapped to muda_trunc_ps().
    -- 
    -- NOTE: SSE4 has _mm_trunc_ps() intrinsic function?.
    --
    IR.ETrunc sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "muda_trunc_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- round(x).
    -- Mapped to itof(ftoi(x)) = _mm_cvtepi32_ps(_mm_cvtps_epi32(x)).
    -- Assume rounding mode is set to round-to-nearest.
    -- 
    -- NOTE: Assume default rounding mode, i.e. round-to-nearest.    
    -- NOTE: SSE4 has _mm_round_ps() intrinsic function.
    --
    IR.ERound sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "_mm_cvtepi32_ps(_mm_cvtps_epi32("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr "))"
                   , docStr ";"
                   ]

    --
    -- min(a, b).
    --
    IR.EMin sym exps  -> prtBinOp "_mm_min_ps" sym (exps !! 0) (exps !! 1)

    --
    -- max(a, b).
    -- Mapped to
    --
    IR.EMax sym exps  -> prtBinOp "_mm_max_ps" sym (exps !! 0) (exps !! 1)

    --
    -- gather(a).
    -- Mapped to movemask, i.e., gather MSB bits.
    --
    IR.EGather sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "_mm_movemask_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- all(a).
    -- Mapped to, 
    --
    -- %i  = bitcast <4xfloat> %v to <4xi32>
    -- %r0 = extractelement <4xi32> %i, i32 0
    -- %r1 = extractelement <4xi32> %i, i32 1
    -- %r2 = extractelement <4xi32> %i, i32 2
    -- %r3 = extractelement <4xi32> %i, i32 3
    -- %m0 = q
    --
    --
    --
    --
    IR.EAll sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "(__m128)_mm_cmpeq_epi32(_mm_set1_epi32(15), _mm_set1_epi32(_mm_movemask_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")))"
                   , docStr ";"
                   ]

    --
    -- any(a).
    -- Mapped to movemask(x) > 0x0.
    --
    IR.EAny sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "(__m128)_mm_cmpgt_epi32(_mm_set1_epi32(_mm_movemask_ps("
                   , prtFuncArgSyms $ [exps !! 0]
                   , docStr ")), _mm_set1_epi32(0))"
                   , docStr ";"
                   ]


    --
    -- struct field selector.
    --
    IR.EFieldSelect sym id exp
        -> concatD [ prt exp
                   , prtSymConstDef sym
                   , docStr "="
                   , docStr "("
                   , docStr $ structVarNameFromExp exp
                   , docStr $ accessorStr (Sym.getQuals $ IR.getSymFromExp exp)
                   , prt id
                   , docStr ")"
                   , docStr ";"
                   ]

      where
        
        structVarNameFromExp :: IR.Exp -> String
        structVarNameFromExp e = case e of

          --
          -- EIdent is always follwed by ELoad
          --
          (IR.ELoad sym (IR.EIdent _ _))  -> Sym.getName sym 
          (IR.EArray sym _ _)             -> Sym.getName sym 
          _                                   -> error $ "[CodeGenLLVM] TODO(EFieldSelect): " ++ show e

        accessorStr :: [T.Qual] -> String
        accessorStr ty = case ty of 
          [T.InputQual]  -> "->"
          [T.OutputQual] -> "->"
          _              -> "."


    --
    -- swizzle op.
    -- Mapped to shufflevector. 
    --
    -- %r = shufflevector %exp, undef, <swizzle>
    --
    IR.ESwizzle sym swizzleIndex exp

        -> concatD [ prt exp
                   -- , if (isLeafExp exp) then prtLoad symExp tempRegExp
                   --                      else docStr ""
                   , prtSym sym
                   , docStr "="
                   , docStr "shufflevector"
                   , prtTy $ Sym.getType (IR.getSymFromExp exp)
                   , docStr regExp
                   , docStr ","
                   , prtTy $ Sym.getType (IR.getSymFromExp exp)
                   , docStr "undef"
                   , docStr ","
                   , prtTy T.IVec
                   , docStr "<"
                   , prtSwizzleIndex swizzleIndex
                   , docStr ">"
                   , docStr ";"
                   ]

          where

            symExp     = IR.getSymFromExp exp
            tempRegExp = mkTempReg symExp

            regExp     = if (isLeafExp exp) then tempRegExp
                                            else regNameOfSym (IR.getSymFromExp exp)


            prtSwizzleIndex :: [Int] -> Doc
            prtSwizzleIndex []     = concatD []
            prtSwizzleIndex [d]    = concatD [docStr $ "i32 " ++ show d]
            prtSwizzleIndex (d:ds) = concatD [docStr $ "i32 " ++ show d, docStr ",", prtSwizzleIndex ds]

    --
    -- abs(a).
    -- Mapped to muda_abs_vf4(a)
    --
    IR.EAbs sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , prtSymConstDef sym
      , docStr "="
      , docStr "call <4xfloat> @muda_abs_vf4( <4xfloat> "
      , prtSymOfExp (exps !! 0)
      , docStr ") nounwind ;"
      , docStr "\n"
      ]

    --
    -- as_ivec(a).
    -- Mapped to bitcast <4xfloat> to <4xi32>
    --
    IR.EAsIVec sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , prtSym sym
      , docStr "="
      , docStr "bitcast"
      , docStr "<4xfloat>"
      , prtSymOfExp (exps !! 0)
      , docStr "<4xi32>"
      , docStr ";"
      ]

    --
    -- as_vec(a).
    -- Mapped to bitcast <4xi32> to <4xfloat>
    --
    IR.EAsVec sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , prtSym sym
      , docStr "="
      , docStr "bitcast"
      , docStr "<4xi32>"
      , prtSymOfExp (exps !! 0)
      , docStr "<4xfloat>"
      , docStr ";"
      ]

      
    _ -> error ("[CodeGenLLVM] TODO(Unimplemented): " ++ (show e))



--
-- print struct field with 16byte-padding for each field.
-- e.g. "int" type field has another 3 ints to align 16 byte.  
--
-- TODO: - Handle struct in struct.
--       - Do much more sophisticated packing.
--
instance CodeGenLLVM IR.MDec where
  prt p = case p of
    IR.MDecl ty id structId -> case (getTypeName ty) of
      "int" -> concatD
                       [ prt ty, docStr ","
                       , prt ty, docStr ","
                       , prt ty, docStr ","
                       , prt ty
                       ]

      "float" -> concatD
                       [ prt ty, docStr ","
                       , prt ty, docStr ","
                       , prt ty, docStr ","
                       , prt ty
                       ]

      "vec" -> concatD
                       [ prt ty
                       ]

      "ivec" -> concatD
                       [ prt ty
                       ]

      _      -> error "[CodeGenLLVM] IR.MDecl: TODO"

    where

        getTypeName :: IR.Typ -> String
        getTypeName (IR.TName (IR.Ident tname)) = tname

  prtList ps = case ps of
    []     -> concatD []
    [x]    -> concatD [prt x]
    (x:xs) -> concatD [prt x, docStr ",", prt xs]

--
-- TODO: Add padding.
--
instance CodeGenLLVM IR.Struc where
  prt s = case s of
    IR.Struct id mdecs -> concatD [ docStr $ mkStructName id
                                  , docStr "="
                                  , docStr "type"
                                  , docStr "{"
                                  , prt mdecs
                                  , docStr "}\n\n"
                                  ]

    where
    
      mkStructName :: IR.Ident -> String
      mkStructName (IR.Ident i) = "%" ++ i

  prtList ss = case ss of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]


--
-- TODO: Handle mdec with  out or array qualifier.
--
--   %var.addr = alloca
--   store %var, %var.addr
--
prtFormalDecMem :: IR.FormalDec -> Doc 
prtFormalDecMem (IR.FormalDecl sym quals ty id) = concatD
  [ docStr decRegMem
  , docStr "="
  , docStr "alloca"
  , prt ty
  , docStr ";"

  --

  , docStr "store"
  , prt ty
  , docStr decReg
  , docStr ","
  , prtTyRef $ convTy ty
  , docStr decRegMem
  , docStr ";"
  ]

  where

    decReg    = "%" ++ (IR.stringFromIdent id)
    decRegMem = "%" ++ (IR.stringFromIdent id) ++ ".addr"


instance CodeGenLLVM IR.Func where
  prt f = case f of
    IR.Fun specs ty id formaldecs stms ->
      concatD [ docStr "define"
              , prt specs
              , prt ty
              , prtFuncId id
              , docStr "("
              , prt formaldecs
              , docStr ")"
              , docStr "{"
              , concatD (map prtFormalDecMem formaldecs)
              -- , docStr "entry:\n"
              , prt stms
              , docStr "}"
              , docStr "\n"
              ]

      where
      
        prtFuncId :: IR.Ident -> Doc
        prtFuncId (IR.Ident str) = docStr ("@" ++ str)
    
  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]

--
-- TODO: Handle qual specfier.
--
instance CodeGenLLVM IR.FormalDec where
  prt e = case e of
    IR.FormalDecl sym quals ty id -> case (Sym.getQuals sym) of
      [T.InputQual]  -> (concatD [prt ty, prtArgId id])
      [T.InOutQual]  -> (concatD [prt ty, docStr "*", prtArgId id])
      [T.OutputQual] -> (concatD [prt ty, docStr "*", prtArgId id])
      [T.ArrayQual]  -> (concatD [prt ty, docStr "*", prtArgId id])
      _              -> (concatD [prt ty, prt id])

    where

      prtArgId :: IR.Ident -> Doc
      prtArgId (IR.Ident str) = docStr ("%" ++ str)


  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, doc (showString ","), prt xs])


--
-- Print header
--
--
-- Add target info:
--
--   float is 32-bit aligned(TODO: Change to 128-bit aligned?).
--   i32   is 32-bit aligned(TODO: Change to 128-bit aligned?).
--   v128  is 128-bit
--
headerString :: String
headerString = unlines
  [ ";;"
  , ";; The following code was generated by MUDA compiler"
  , ";;"
  , "target datalayout = \"i32:128:128-f32:128:128\" "
  , ""
  , ";; Common utility functions"
  , "define <4xfloat> @bit2float(i32 %val) {"
  , "entry:"
  , "    %tmp  = alloca i32"
  , "    store i32 %val, i32* %tmp"
  , ""
  , "    %f.addr = bitcast i32* %tmp to float*"
  , "    %f0     = load float* %f.addr"
  , "    %vtmp0  = insertelement <4xfloat> undef,  float %f0, i32 0"
  , "    %vtmp1  = insertelement <4xfloat> %vtmp0, float %f0, i32 1"
  , "    %vtmp2  = insertelement <4xfloat> %vtmp1, float %f0, i32 2"
  , "    %vtmp3  = insertelement <4xfloat> %vtmp2, float %f0, i32 3"
  , ""
  , "    ret <4xfloat> %vtmp3"
  , "}"
  , ""
  , "define <4xfloat> @muda_sel_vf4(<4xfloat> %a, <4xfloat> %b, <4xi32> %mask) {"
  , "entry:"
  , "    %a.i     = bitcast <4xfloat> %a to <4xi32>"
  , "    %b.i     = bitcast <4xfloat> %b to <4xi32>"
  , "    %tmp0    = and <4xi32> %b.i, %mask"
  , "    %tmp.addr = alloca <4xi32>"
  , "    store <4xi32> <i32 -1, i32 -1, i32 -1, i32 -1>, <4xi32>* %tmp.addr"
  , "    %allone  = load <4xi32>* %tmp.addr"
  , "    %invmask = xor <4xi32> %allone, %mask"
  , "    %tmp1    = and <4xi32> %a.i, %invmask"
  , "    %tmp2    = or <4xi32> %tmp0, %tmp1"
  , "    %r       = bitcast <4xi32> %tmp2 to <4xfloat>"
  , ""
  , "    ret <4xfloat> %r"
  , "}"
  , ""
  , "; ((a << 1) >> 1)"
  , "define <4xfloat> @muda_abs_vf4(<4xfloat> %a) {"
  , "entry:"
  , "    %a.i     = bitcast <4xfloat> %a to <4xi32>"
  , "    %i0      = extractelement <4xi32> %a.i, i32 0"
  , "    %i1      = extractelement <4xi32> %a.i, i32 1"
  , "    %i2      = extractelement <4xi32> %a.i, i32 2"
  , "    %i3      = extractelement <4xi32> %a.i, i32 3"
  , "    %tmp0_0  = shl i32 %i0, 1"
  , "    %tmp0_1  = shl i32 %i1, 1"
  , "    %tmp0_2  = shl i32 %i2, 1"
  , "    %tmp0_3  = shl i32 %i3, 1"
  , "    %tmp1_0  = ashr i32 %tmp0_0, 1"
  , "    %tmp1_1  = ashr i32 %tmp0_1, 1"
  , "    %tmp1_2  = ashr i32 %tmp0_2, 1"
  , "    %tmp1_3  = ashr i32 %tmp0_3, 1"
  , "    %tmpi_0  = insertelement <4xi32> undef  , i32 %tmp1_0, i32 0"
  , "    %tmpi_1  = insertelement <4xi32> %tmpi_0, i32 %tmp1_1, i32 1"
  , "    %tmpi_2  = insertelement <4xi32> %tmpi_1, i32 %tmp1_2, i32 2"
  , "    %tmpi_3  = insertelement <4xi32> %tmpi_2, i32 %tmp1_3, i32 3"
  , "    %a.f     = bitcast <4xi32> %tmpi_3 to <4xfloat>"
  , ""
  , "    ret <4xfloat> %a.f"
  , "}"
  , ""
  ]


--
-- %sym = alloca type
--
prtSymDef :: Sym.Sym -> Doc
prtSymDef sym = concatD [ prtSym sym
                        , docStr "= alloca "
                        , prt (Sym.getType sym)
                        , docStr ";"
                        ]

--
-- %sym = alloca type*
--
prtSymDefPtr :: Sym.Sym -> Doc
prtSymDefPtr sym = concatD
                        [ prtSym sym
                        , docStr "= alloca "
                        , prt (Sym.getType sym)
                        , docStr ";"
                        ]

--
-- %sym.suffix = alloca type
--
prtSymDefWithSuffix :: Sym.Sym -> String -> Doc
prtSymDefWithSuffix sym prefix = concatD [ prtSymWithSuffix sym prefix
                                         , docStr "= alloca "
                                         , prt (Sym.getType sym)
                                         ]


prtSymMemRef:: Sym.Sym -> Doc
prtSymMemRef sym = concatD [ prtTyRef (Sym.getType sym)
                           , docStr reg
                           ]

                   where

                     reg :: Register
                     reg = if (Sym.getKind sym) == Sym.KindFormalVariable
                             then "%" ++ (Sym.getName sym) ++ ".addr"  
                             else "%" ++ (Sym.getName sym) 

--
-- type*  %sym
--
prtSymRef:: Sym.Sym -> Doc
prtSymRef sym = concatD [ prtTyRef (Sym.getType sym)
                        , prtSym sym
                        ]

--
-- type**  %sym
--
prtSymRefRef:: Sym.Sym -> Doc
prtSymRefRef sym = concatD [ prtTyRefRef (Sym.getType sym)
                           , prtSym sym
                           ]

--
-- type*  %sym.suffix
--
prtSymRefWithSuffix:: Sym.Sym -> String -> Doc
prtSymRefWithSuffix sym prefix = concatD [ prtTyRef (Sym.getType sym)
                                         , prtSymWithSuffix sym prefix
                                         ]

--
-- TODO: to be removed
--
prtSymConstDef :: Sym.Sym -> Doc
prtSymConstDef sym = concatD [ prtTyRef (Sym.getType sym)
                             , docStr (Sym.getName sym)
                             ]

--
-- %sym
--
prtSym :: Sym.Sym -> Doc
prtSym sym = concatD [ docStr $ "%" ++ (Sym.getName sym) ]

--
-- %sym.suffix
--
prtSymWithSuffix :: Sym.Sym -> String -> Doc
prtSymWithSuffix sym prefix = concatD [ docStr $ "%" ++ (Sym.getName sym) ++ prefix ]


prtTy :: T.Typ -> Doc
prtTy = docStr . strOfType

prtTyRef :: T.Typ -> Doc
prtTyRef ty = docStr (strOfType ty ++ "*")

prtTyRefRef :: T.Typ -> Doc
prtTyRefRef ty = docStr (strOfType ty ++ "**")

prtSymOfExp :: IR.Exp -> Doc
prtSymOfExp exp = prtSym $ IR.getSymFromExp exp

docStr :: String -> Doc
docStr str = doc (showString str)

instance CodeGenLLVM IR.DecInitExp where
  prt e = case e of
    IR.DExp sym exp          -> concatD [prt exp]

instance CodeGenLLVM IR.DecInit where
  prt d = case d of
    IR.DeclInit id []        -> concatD []
    IR.DeclInit id [initExp] -> concatD [prt initExp]
    _                        -> error "???"
    

instance CodeGenLLVM IR.Stm where
  prt e = case e of
    IR.SDecl sym ty (IR.DeclInit declid []) ->
                                 concatD [prtSymDef sym]

    --
    -- %r = alloca
    -- store %exp, %r
    --
    IR.SDecl sym ty (IR.DeclInit declid [initExp]) -> concatD

      [ prt initExp
      , prtSymDef sym

      --

      , docStr "store"
      , prtTy (Sym.getType symExp)
      , prtSym symExp
      , docStr ","
      , prtSymRef sym
      , docStr ";"
      ]

      where

        symExp :: Sym.Sym
        symExp = IR.getSymFromDExp initExp


    --
    -- "%sym = %tmp" expression is handles as,
    --
    -- %tmp = load %exp
    -- store %tmp, %sym
    --
    IR.SAssign sym id exp ->

      concatD [ prt exp
              , docStr "store"
              , prtTy (Sym.getType sym)
              , docStr expReg
              , docStr ","
              , prtSymMemRef sym
              , docStr ";"
              ]

      where

        expReg :: String
        expReg = regNameOfSym (IR.getSymFromExp exp)


    --
    -- Use brute force assignment.
    --
    -- a.xy = v is mapped to.
    --
    -- float tmp[4];
    -- _mm_storeu_ps(tmp, v);
    --
    -- ((float *)&a)[0] = tmp[0];
    -- ((float *)&a)[1] = tmp[1];
    --
    --
    -- TODO: Optimize!
    --       - Use shuffle instruction for (length swizzleIndex) == 4 case.
    --       - SSE4 may have partial update instruction.
    --
    IR.SAssignWithSwizzle sym id swizzleIndex exp
        ->  concatD [ prt exp
                    , prtVtoArray T.F sym tmpSymStr exp
                    , prtAssignWithSwizzle swizzleIndex 0 leftSymStr rightSymStr
                    ]
            
            where

              tmpSymStr :: String
              tmpSymStr = Sym.genSymName T.F

              leftSymStr  = Sym.getName sym
              rightSymStr = tmpSymStr 

              prtAssignWithSwizzle :: [Int] -> Int -> String -> String -> Doc

              prtAssignWithSwizzle []     pos lhs rhs = concatD []
              prtAssignWithSwizzle [d]    pos lhs rhs =
                concatD [ prtAssignWithSwizzleOp d pos lhs rhs ]

              prtAssignWithSwizzle (d:ds) pos lhs rhs =
                concatD [ prtAssignWithSwizzleOp d pos lhs rhs
                        , docStr "\n"
                        , prtAssignWithSwizzle ds (pos + 1) lhs rhs
                        ]

              -- TODO: fix me
              prtAssignWithSwizzleOp :: Int -> Int -> String -> String -> Doc
              prtAssignWithSwizzleOp idx pos lhs rhs =
                docStr ("((float *)&" ++ lhs ++ ")[" ++ show idx ++ "]" ++
                        " = " ++ rhs ++ "[" ++ show pos ++ "];")
              
  
              
    IR.SAssignWithField sym id fields exp
                              -> concatD [ prt exp
                                         , docStr "("
                                         , prtSym sym
                                         , docStr $ accessorStr (Sym.getQuals sym)
                                         , docStr $ fieldName (fields !! 0)
                                         , docStr ")"
                                         , docStr "="
                                         , prtSym (IR.getSymFromExp exp)
                                         , docStr ";"
                                         ]

      where

        fieldName :: IR.Field -> String
        fieldName (IR.EField (IR.Ident str)) = str
        
        accessorStr :: [T.Qual] -> String
        accessorStr ty = case ty of 
          [T.InputQual]  -> "->"
          _            -> "."

    --
    -- Compound statement. Enclose the statement in parentheses.
    --
    IR.SBlock stms          -> concatD [docStr "{",
                                        prt stms,
                                        docStr "}"]

    --
    -- Do some tricks.
    --
    -- while (exp) { stm }
    --
    -- is converted to,
    --
    -- expand(exp);
    -- while (root(exp)) {
    --     stm;
    --     expand(exp);
    -- }
    --
    IR.SWhile exp stms      -> concatD [prt exp,
                                        docStr "while",
                                        docStr "(",
                                        prtSymOfExp exp,
                                        docStr ")",
                                        docStr "{",
                                        prt stms,
                                        prt exp,
                                        docStr "}"]

    --
    -- Use "br" instruction.
    -- "br" acceps i1(boolean) value for its condition.
    --
    -- %tmp0 = bitcast float %exp to i32 
    -- %cnd  = trunc 
    -- 
    --

    IR.SIf exp ifStms elseStms -> concatD


      [ prt exp

      -- bitcast. assume type of exp is float vector

      , prtBitcast (tmpReg, T.I) (regNameOfSymFromExp exp, T.F)

      -- trunc

      , docStr cndReg
      , docStr "="
      , docStr "trunc"
      , docStr "i32"
      , docStr tmpReg
      , docStr "to"
      , docStr "i1"

      -- br

      , docStr "br"
      , docStr "i1"
      , docStr cndReg
      , docStr ","
      , docStr "label"
      , docStr $ "%" ++ thenLabel
      , docStr ","
      , docStr "label"
      , docStr $ "%" ++ elseLabel
      , docStr ";"
      , docStr "\n"

      -- print then statement

      , docStr $ thenLabel ++ ":"
      , prt ifStms
      , docStr $ "br label %" ++ endLabel
      , docStr ";"

      -- print else statement

      , docStr $ elseLabel ++ ":"
      , prt elseStms
      , docStr $ "br label %" ++ endLabel
      , docStr ";"

      -- print end statement

      , docStr $ endLabel ++ ":"
      , docStr ";"

      ]

      where

        fReg      = mkTempRegFromTy T.F
        cndReg    = mkTempRegFromTy T.I     -- Although %cndReg is used as a 
                                            -- register of i1 type

        tmpReg    = mkTempRegFromTy T.I

        thenLabel = mkLabel "then"
        elseLabel = mkLabel "else"
        endLabel  = mkLabel "end"


    IR.SReturnVoid          -> concatD 
      [ docStr "ret void"
      , docStr ";"
      ]


    IR.SReturn exp          -> concatD 
      [ prt exp
      , docStr "ret"
      , prtTy (Sym.getType $ IR.getSymFromExp exp)
      , prtSym (IR.getSymFromExp exp)
      , docStr ";"
      ]

    _ -> error $ "[CodeGenLLVM] TODO: " ++ show e

  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, docStr "\n",  prt xs])


instance CodeGenLLVM IR.FuncSpec where
  prt f = case f of
    IR.InlineFuncSpec       -> doc $ showString ""  -- emit nothing
    IR.ForceInlineFuncSpec  -> doc $ showString ""
    IR.AlwaysInlineFuncSpec -> doc $ showString ""
    IR.StaticFuncSpec       -> doc $ showString "internal"

  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]



instance CodeGenLLVM IR.Prog where
  prt p = case p of
    IR.Program structs funcs -> concatD [prt structs, prt funcs]


-- TODO: convert to pointer type.
-- convQual :: IR.Qual -> String
-- convQual q = case q of
--   IR.InputQual  -> "in"
--   IR.OutputQual -> "out"
--   IR.InOutQual  -> "inout"
-- 
-- 
-- instance CodeGenLLVM IR.Qual where
--   prt q = concatD [doc (showString $ convQual q)]
-- 
--   prtList es = case es of
--     [] -> (concatD [])
--     x:xs -> (concatD [prt x , prt xs])


instance CodeGenLLVM IR.Ident where
  prt (IR.Ident i) = doc (showString i)

convType :: String -> String
convType s = case s of
  "vec"  -> "<4xfloat>"
  "dvec" -> "<4xdouble>"
  "ivec" -> "<4xi32>"
  "lvec" -> "<4xi64>"
  "int"  -> "i32"
  s      -> s

strOfType :: T.Typ -> String
strOfType ty = convType $ T.strOfType ty

instance CodeGenLLVM IR.Typ where
  prt (IR.TName e) = case e of
    (IR.Ident tname) -> concatD [doc (showString $ convType tname)] 

instance CodeGenLLVM T.Typ where
  prt ty = concatD [doc (showString $ strOfType ty)] 


getConstantInt :: IR.Exp -> Integer
getConstantInt exp = case exp of
  (IR.EItoIV _ (IR.ELoad _ (IR.EInt _ i))) -> i
  _                           -> error $ "Unknown expression for getConstantInt: " ++ show exp

prtShuffleConstant :: Integer -> Doc
prtShuffleConstant i = 
  concatD [ docStr "_MM_SHUFFLE(",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ")"
          ]

-- vim: set ts=2 sw=2 expandtab:

