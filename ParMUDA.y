-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParMUDA where
import AbsMUDA
import LexMUDA
import ErrM

}

%name pProg Prog
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '&' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '.' { PT _ (TS _ 9) }
  '/' { PT _ (TS _ 10) }
  '/.' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<<' { PT _ (TS _ 14) }
  '<<<' { PT _ (TS _ 15) }
  '<<<|' { PT _ (TS _ 16) }
  '<<|' { PT _ (TS _ 17) }
  '<=' { PT _ (TS _ 18) }
  '=' { PT _ (TS _ 19) }
  '==' { PT _ (TS _ 20) }
  '>' { PT _ (TS _ 21) }
  '>=' { PT _ (TS _ 22) }
  '>>' { PT _ (TS _ 23) }
  '>>>' { PT _ (TS _ 24) }
  '>>>|' { PT _ (TS _ 25) }
  '>>|' { PT _ (TS _ 26) }
  '[' { PT _ (TS _ 27) }
  ']' { PT _ (TS _ 28) }
  '^' { PT _ (TS _ 29) }
  'always_inline' { PT _ (TS _ 30) }
  'array' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'force_inline' { PT _ (TS _ 33) }
  'if' { PT _ (TS _ 34) }
  'in' { PT _ (TS _ 35) }
  'inline' { PT _ (TS _ 36) }
  'inout' { PT _ (TS _ 37) }
  'new' { PT _ (TS _ 38) }
  'out' { PT _ (TS _ 39) }
  'return' { PT _ (TS _ 40) }
  'static' { PT _ (TS _ 41) }
  'struct' { PT _ (TS _ 42) }
  'while' { PT _ (TS _ 43) }
  '{' { PT _ (TS _ 44) }
  '|' { PT _ (TS _ 45) }
  '}' { PT _ (TS _ 46) }
  '~' { PT _ (TS _ 47) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_CFloat { PT _ (T_CFloat $$) }
L_CDouble { PT _ (T_CDouble $$) }
L_Hexadecimal { PT _ (T_Hexadecimal $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
CFloat    :: { CFloat} : L_CFloat { CFloat ($1)}
CDouble    :: { CDouble} : L_CDouble { CDouble ($1)}
Hexadecimal    :: { Hexadecimal} : L_Hexadecimal { Hexadecimal ($1)}

Prog :: { Prog }
Prog : ListStruc ListFunc { AbsMUDA.Program (reverse $1) (reverse $2) }
ListStruc :: { [Struc] }
ListStruc : {- empty -} { [] } | ListStruc Struc { flip (:) $1 $2 }
Struc :: { Struc }
Struc : 'struct' Ident '{' ListMDec '}' ';' { AbsMUDA.Struct $2 $4 }
ListMDec :: { [MDec] }
ListMDec : MDec { (:[]) $1 } | MDec ListMDec { (:) $1 $2 }
MDec :: { MDec }
MDec : Typ Ident ';' { AbsMUDA.MDecl $1 $2 }
ListFunc :: { [Func] }
ListFunc : {- empty -} { [] } | ListFunc Func { flip (:) $1 $2 }
Func :: { Func }
Func : ListFuncSpec Typ Ident '(' ListFormalDec ')' '{' ListStm '}' { AbsMUDA.Fun (reverse $1) $2 $3 $5 (reverse $8) }
ListFuncSpec :: { [FuncSpec] }
ListFuncSpec : {- empty -} { [] }
             | ListFuncSpec FuncSpec { flip (:) $1 $2 }
FuncSpec :: { FuncSpec }
FuncSpec : 'inline' { AbsMUDA.InlineFuncSpec }
         | 'force_inline' { AbsMUDA.ForceInlineFuncSpec }
         | 'always_inline' { AbsMUDA.AlwaysInlineFuncSpec }
         | 'static' { AbsMUDA.StaticFuncSpec }
FormalDec :: { FormalDec }
FormalDec : ListQual Typ Ident { AbsMUDA.FormalDecl (reverse $1) $2 $3 }
ListFormalDec :: { [FormalDec] }
ListFormalDec : {- empty -} { [] }
              | FormalDec { (:[]) $1 }
              | FormalDec ',' ListFormalDec { (:) $1 $3 }
ListDecInit :: { [DecInit] }
ListDecInit : DecInit { (:[]) $1 }
            | DecInit ',' ListDecInit { (:) $1 $3 }
DecInit :: { DecInit }
DecInit : Ident ListDecInitExp { AbsMUDA.DeclInit $1 $2 }
ListDecInitExp :: { [DecInitExp] }
ListDecInitExp : {- empty -} { [] } | DecInitExp { (:[]) $1 }
DecInitExp :: { DecInitExp }
DecInitExp : '=' Exp { AbsMUDA.DExp $2 }
Qual :: { Qual }
Qual : 'in' { AbsMUDA.InputQual }
     | 'out' { AbsMUDA.OutputQual }
     | 'inout' { AbsMUDA.InOutQual }
     | 'array' { AbsMUDA.ArrayQual }
ListQual :: { [Qual] }
ListQual : {- empty -} { [] } | ListQual Qual { flip (:) $1 $2 }
Stm :: { Stm }
Stm : Typ ListDecInit ';' { AbsMUDA.SDecl $1 $2 }
    | Ident '=' Exp ';' { AbsMUDA.SAssign $1 $3 }
    | Ident '.' ListField '=' Exp ';' { AbsMUDA.SAssignWithField $1 $3 $5 }
    | Ident '[' Exp ']' '=' Exp ';' { AbsMUDA.SAssignWithArray $1 $3 $6 }
    | Exp ';' { AbsMUDA.SExp $1 }
    | '{' ListStm '}' { AbsMUDA.SBlock (reverse $2) }
    | 'while' '(' Exp ')' Stm { AbsMUDA.SWhile $3 $5 }
    | 'if' '(' Exp ')' '{' ListStm '}' 'else' '{' ListStm '}' { AbsMUDA.SIf $3 (reverse $6) (reverse $10) }
    | 'return' Exp ';' { AbsMUDA.SReturn $2 }
    | 'return' ';' { AbsMUDA.SReturnVoid }
    | Ident '=' 'new' Integer ';' { AbsMUDA.SNew $1 $4 }
    | Stm ';' { $1 }
ListStm :: { [Stm] }
ListStm : {- empty -} { [] } | ListStm Stm { flip (:) $1 $2 }
ListExp :: { [Exp] }
ListExp : {- empty -} { [] } | ListExp Exp { flip (:) $1 $2 }
Exp :: { Exp }
Exp : Exp '&' Exp1 { AbsMUDA.EAnd $1 $3 }
    | Exp '|' Exp1 { AbsMUDA.EOr $1 $3 }
    | Exp '^' Exp1 { AbsMUDA.EXor $1 $3 }
    | Exp '~' Exp1 { AbsMUDA.ENot $1 $3 }
    | Exp1 { $1 }
Exp1 :: { Exp }
Exp1 : Exp1 '==' Exp2 { AbsMUDA.EEq $1 $3 }
     | Exp1 '!=' Exp2 { AbsMUDA.ENeq $1 $3 }
     | Exp2 { $1 }
Exp2 :: { Exp }
Exp2 : Exp2 '>' Exp3 { AbsMUDA.EGt $1 $3 }
     | Exp2 '>=' Exp3 { AbsMUDA.EGte $1 $3 }
     | Exp2 '<' Exp3 { AbsMUDA.ELt $1 $3 }
     | Exp2 '<=' Exp3 { AbsMUDA.ELte $1 $3 }
     | Exp3 { $1 }
Exp3 :: { Exp }
Exp3 : Exp3 '<<' Exp4 { AbsMUDA.ESlElemWise $1 $3 }
     | Exp3 '>>' Exp4 { AbsMUDA.ESrElemWise $1 $3 }
     | Exp3 '<<<' Exp4 { AbsMUDA.ESlaElemWise $1 $3 }
     | Exp3 '>>>' Exp4 { AbsMUDA.ESraElemWise $1 $3 }
     | Exp3 '<<|' Exp4 { AbsMUDA.ESlQWord $1 $3 }
     | Exp3 '>>|' Exp4 { AbsMUDA.ESrQWord $1 $3 }
     | Exp3 '<<<|' Exp4 { AbsMUDA.ESlaQWord $1 $3 }
     | Exp3 '>>>|' Exp4 { AbsMUDA.ESraQWord $1 $3 }
     | Exp4 { $1 }
Exp4 :: { Exp }
Exp4 : Exp4 '+' Exp5 { AbsMUDA.EAdd $1 $3 }
     | Exp4 '-' Exp5 { AbsMUDA.ESub $1 $3 }
     | Exp5 { $1 }
Exp5 :: { Exp }
Exp5 : Exp5 '*' Exp6 { AbsMUDA.EMul $1 $3 }
     | Exp5 '/' Exp6 { AbsMUDA.EDiv $1 $3 }
     | Exp5 '/.' Exp6 { AbsMUDA.EDivApprox $1 $3 }
     | Exp6 { $1 }
Exp6 :: { Exp }
Exp6 : '-' Exp7 { AbsMUDA.ENeg $2 } | Exp7 { $1 }
Exp7 :: { Exp }
Exp7 : Exp6 '.' ListField { AbsMUDA.EFieldSelect $1 $3 }
     | Exp8 { $1 }
Exp8 :: { Exp }
Exp8 : Exp8 '[' Exp ']' { AbsMUDA.EArray $1 $3 }
     | Ident '(' ListFuncArgs ')' { AbsMUDA.EFunc $1 $3 }
     | Exp9 { $1 }
Exp9 :: { Exp }
Exp9 : Ident { AbsMUDA.EIdent $1 }
     | Integer { AbsMUDA.EInt $1 }
     | Double { AbsMUDA.EDouble $1 }
     | CFloat { AbsMUDA.ECFloat $1 }
     | Hexadecimal { AbsMUDA.EHexadec $1 }
     | '(' Exp ')' { $2 }
ListFuncArgs :: { [FuncArgs] }
ListFuncArgs : {- empty -} { [] }
             | FuncArgs { (:[]) $1 }
             | FuncArgs ',' ListFuncArgs { (:) $1 $3 }
FuncArgs :: { FuncArgs }
FuncArgs : Exp1 { AbsMUDA.EArg $1 }
ListField :: { [Field] }
ListField : Field { (:[]) $1 } | Field '.' ListField { (:) $1 $3 }
Field :: { Field }
Field : Ident { AbsMUDA.EField $1 }
Typ :: { Typ }
Typ : Ident { AbsMUDA.TName $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

