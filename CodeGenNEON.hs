-------------------------------------------------------------------------------
---- |
---- Module      :  CodeGenNEON
---- Copyright   :  (c) Syoyo Fujita
---- License     :  BSD-style
----
---- Maintainer  :  syoyo@lighttransport.com
---- Stability   :  experimental
---- Portability :  GHC 7.6
----
---- CodeGenNEON  :  Code generator for ARM NEON.
----
-------------------------------------------------------------------------------
module CodeGenNEON where

import Debug.Trace
import Text.Regex

import Data.Char
import qualified IR
import qualified Sym
import qualified TypeMUDA as T

-- pretty-printer grabbed from PrintMUDA.hs generated by the BNF converter
-- with small modification.

-- the top-level printing method of the tree
printTree :: (CodeGenNEON a) => a -> String
-- printTree tree = headerString ++ (render $ prt tree)
printTree tree = "#include \"mudaintrin_neon.h\"\n\n" ++(render $ prt tree)

-- the top-level printing method to output the header file
printHeader :: IR.Prog -> String
printHeader tree = (render $ prtHeader tree)

printIntrinsicHeader :: String
printIntrinsicHeader = headerString

type Doc = [ShowS] -> [ShowS]

type Register = String
data AccessMode = ReadMode | AssignMode

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> new i . showChar '{' . new (i+1) . rend (i+1) ts
    -- "} else {" :ts -> trace "else" $ new (i-1) . showString "} else {" . new i . rend i ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    t  : "}" :ts -> showString t . new (i-1) . showString "}" . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    --";"      :ts -> showChar ';' . new i . rend i ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    "\n"     :ts -> new i . rend i ts
    t  : "," :ts -> showString t . space "," . rend i ts
    t  : ")" :ts -> showString t . showString ") " . rend i ts
    t  : "]" :ts -> showString t . showChar ']' . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  --new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile isSpace
  new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile (\x -> x == ' ')
  -- new2 ii  = trace "new2" $ showChar '\n'
  space t = showString t . (\s -> if null s then "" else (' ':s))

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

instance CodeGenNEON Char where
  prt s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

--
-- CodeGenNEON class
--

class CodeGenNEON a where
  prt :: a -> Doc
  prtList :: [a] -> Doc
  prtList = concatD . map prt


instance CodeGenNEON a => CodeGenNEON [a] where
  prt = prtList


--
-- TODO: If this routine will not used, remove.
--
isVector :: T.Typ -> Bool
isVector ty
  | ty == T.Vec  = True
  | ty == T.IVec = True 
  | otherwise    = False 

isScalar :: T.Typ -> Bool
isScalar ty
  | ty == T.F  = True
  | ty == T.I  = True 
  | otherwise  = False 

isPointer :: [T.Qual] -> Bool
isPointer q 
  | any (T.InOutQual  ==) q = True
  | any (T.OutputQual ==) q = True
  | any (T.ArrayQual  ==) q = True
  | otherwise               = False

isMutable :: [T.Qual] -> Bool
isMutable q 
  | any (T.InOutQual  ==) q = False
  | any (T.OutputQual ==) q = False
  | any (T.ArrayQual  ==) q = False
  | otherwise               = True

isExternal :: [IR.FuncSpec] -> Bool
isExternal s
  | any (IR.StaticFuncSpec ==)       s = False
  | any (IR.InlineFuncSpec ==)       s = False
  | any (IR.ForceInlineFuncSpec ==)  s = False
  | any (IR.AlwaysInlineFuncSpec ==) s = False
  | otherwise                          = True


tyOfExp :: IR.Exp -> T.Typ
tyOfExp = Sym.getType . IR.getSymFromExp


mkTempRegFromTy :: T.Typ -> Register
mkTempRegFromTy ty =
  Sym.getName (Sym.genSym ty [] Sym.KindVariable)



prtBinOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtBinOp opStr sym e0 e1 = concatD [
  prt e0,
  prt e1,
  prtSymConstDef sym,
  docStr " = ",
  docStr (opStr ++ "("),
  prtSymOfExp e0,
  docStr ", ",
  prtSymOfExp e1, 
  docStr " )",
  docStr ";"
  ]

prtBinOpN :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Int -> Doc
prtBinOpN opStr sym e0 e1 n = concatD 
  [ prt e0
  , prt e1
  , emitBinOpN opStr sym e0 e1 n
  ]

  where

  emitBinOpN _     _   _  _  0 = concatD [] 

  emitBinOpN opStr sym e0 e1 nn = concatD 
    [ emitBinOpN opStr sym e0 e1 (nn-1)
    , substDoc "[[rhs]] = [[op]]([[e0]], [[e1]]) ; " binding
    ]
  
    where

      binding = [ ("rhs", render $ prtSymConstDefN sym nn)
                , ("op" , opStr)
                , ("e0" , render $ prtSymOfExpN e0 nn)
                , ("e1" , render $ prtSymOfExpN e1 nn)
                ]

--
-- e1 for shift op should be EItoIV (EInt val)
--
prtShiftOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtShiftOp opStr sym e0 (IR.EItoIV _ intExp) = concatD
  [ prt e0
  , prt intExp
  , prtSymConstDef sym
  , docStr " = "
  , docStr ("(float32x4_t)" ++ opStr ++ "((int32x4_t)")
  , prtSymOfExp e0
  , docStr ", "
  , prtSymOfExp intExp
  , docStr ")" 
  , docStr ";"
  ]

-- TODO
prtShiftOpN :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Int -> Doc
prtShiftOpN opStr sym e0 (IR.EItoIV _ intExp) n = concatD
  [ prt e0
  , prt intExp
  , prtSymConstDefN sym 1
  , docStr " = "
  , docStr (castStr ++ opStr ++ "((int32x4_t)")
  , prtSymOfExpN e0 1
  , docStr ", "
  , prtSymOfExpN intExp 1
  , docStr ")" 
  , docStr ";"
  ]

  where

    castStr = case (Sym.getType sym) of
      T.Vec -> "(float32x4_t)"
      _     -> ""


--
-- Not is mapped to vbicq_s32(x, 0xffffffff)
--                  -> ~x & 0xffffffff
--                  -> ~x
--
prtNotOp sym exp = concatD
  [ prt exp
  , prtSymConstDef sym
  , docStr "="
  , docStr "vbicq_s32("
  , prtSymOfExp exp
  , docStr ","
  , docStr "(float32x4_t)vdupq_n_u32(0xffffffff)"
  , docStr ")"
  , docStr ";"
  ]


prtFormalTy :: T.Typ -> [T.Qual] -> Doc
prtFormalTy t qs = case (t, isPointer qs) of
  (T.Vec  , True ) -> concatD[ docStr "float *" ]
  (T.F    , True ) -> concatD[ docStr "float *" ]
  (T.DVec , True ) -> concatD[ docStr "double *" ]
  (T.D    , True ) -> concatD[ docStr "double *" ]
  (T.IVec , True ) -> concatD[ docStr "int *" ]
  (T.I    , True ) -> concatD[ docStr "int *" ]
  (T.LVec , True ) -> concatD[ docStr "long long *" ]
  (T.L    , True ) -> concatD[ docStr "long long *" ]
  (T.Vec  , False) -> concatD[ docStr "const float *" ]
  (T.F    , False) -> concatD[ docStr "const float" ]
  (T.DVec , False) -> concatD[ docStr "const double *" ]
  (T.D    , False) -> concatD[ docStr "const double" ]
  (T.IVec , False) -> concatD[ docStr "const int *" ]
  (T.I    , False) -> concatD[ docStr "const int" ]
  (T.LVec , False) -> concatD[ docStr "const long long *" ]
  (T.L    , False) -> concatD[ docStr "const long long" ]
  (T.Var s, True ) -> concatD[ docStr $ s ++ " *" ]
  (T.Var s, False) -> concatD[ docStr $ "const " ++ s ++ " *" ]


prtFuncArgSyms :: [IR.Exp] -> Doc
prtFuncArgSyms []     = concatD []
prtFuncArgSyms [e]    = concatD [prtSymOfExp e]
prtFuncArgSyms (e:es) = concatD [prtSymOfExp e, docStr ",", prtFuncArgSyms es]

prtFuncArgSymsN :: [IR.Exp] -> Doc
prtFuncArgSymsN []     = concatD []
prtFuncArgSymsN [e]    = concatD
  [ emitFuncArgSymsV e (vLen (IR.getSymFromExp e))]

prtFuncArgSymsN (e:es) = concatD 
  [ emitFuncArgSymsV e (vLen (IR.getSymFromExp e))
  , docStr ","
  , prtFuncArgSymsN es
  ]

emitFuncArgSymsV :: IR.Exp -> Int -> Doc
emitFuncArgSymsV exp 0 = concatD []
emitFuncArgSymsV exp n = concatD
  [ emitFuncArgSymsV exp (n-1)
  , prtSymOfExpN exp n
  ]


prtFuncArgSymsWithScalalization (e:es) = concatD [prtSymOfExp e, docStr ",", prtFuncArgSyms es]

prtFuncArgSymsWithScalalizationN (e:es) = concatD [prtSymOfExpN e 1, docStr ",", prtFuncArgSymsN es]

prtTypecastForFuncArg :: Sym.Sym -> Doc
prtTypecastForFuncArg sym = case (Sym.getType sym) of
  T.Vec  -> concatD [ docStr "(float *)" ]  
  T.DVec -> concatD [ docStr "(double *)" ]  
  T.IVec -> concatD [ docStr "(int *)" ]  
  _      -> concatD [] 

prtFuncArgSymRefs :: [IR.Exp] -> Doc
prtFuncArgSymRefs []     = concatD []
prtFuncArgSymRefs [e]    = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                   , docStr "&(", prtSymOfExp e, docStr ")"
                                   ]
prtFuncArgSymRefs (e:es) = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                   , docStr "&(", prtSymOfExp e, docStr "),"
                                   , prtFuncArgSymRefs es
                                   ]

prtFuncArgSymRefsN :: [IR.Exp] -> Int -> Doc
prtFuncArgSymRefsN []     n = concatD []
prtFuncArgSymRefsN [e]    n = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                      , docStr "&(", prtSymOfExpN e n, docStr ")"
                                      ]
prtFuncArgSymRefsN (e:es) n = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                    , docStr "&(", prtSymOfExpN e n, docStr "),"
                                    , prtFuncArgSymRefsN es n
                                    ]


prtFtoV :: Sym.Sym -> IR.Exp -> Doc
prtFtoV sym exp = concatD

    [ prtSymConstDefN sym 1
    , docStr "="
    , docStr "vdupq_n_f321( "
    , prtSymOfExpN exp 1
    , docStr " )"
    , docStr ";"
    ]

prtDtoDVN :: Sym.Sym -> IR.Exp -> Int -> Doc
prtDtoDVN sym exp 0 = concatD []
prtDtoDVN sym exp n = concatD

    [ prtDtoDVN sym exp (n-1)

    --
    
    , prtSymConstDefN sym n
    , docStr "="
    , docStr "vdupq_n_f64( "
    , prtSymOfExpN exp 1        -- exp should be scalar.
    , docStr " )"
    , docStr ";"
    ]

-- Signed int
prtItoIV :: Sym.Sym -> IR.Exp -> Doc
prtItoIV sym exp = concatD

    [ prtSymConstDefN sym 1
    , docStr "="
    , docStr "vdupq_n_s32( "
    , prtSymOfExpN exp 1
    , docStr " )"
    , docStr ";"
    ]

--
-- Emits string such like,
--
--  float tmpVar[4];
--  vst1q_f32(tmpVar, v);
--  float fvar = tmpVar[0];
--
-- Use vst1q_f32 for safety for now,
-- but once it is guaranteed that the address stored is aligned to 16 bytes,
-- we could use _mm_store_ps
-- 
--
-- TODO: Refactor! Is there any clever way such like template string in
--       Haskell?
--
prtVtoF :: Sym.Sym -> IR.Exp -> Doc
prtVtoF sym exp =
  concatD [
    docStr $ strOfType T.F,
    docStr $ tmpSymStr ++ "[4]",
    docStr ";",
    docStr "vst1q_f32",
    docStr "(",
    docStr tmpSymStr,
    docStr ",",
    prtSymOfExpN exp 1,
    docStr ")",
    docStr ";",
    prtSymConstDefN sym 1,
    docStr "=",
    docStr $ tmpSymStr ++ "[0]",
    docStr ";"
  ]

  where

    tmpSymStr :: String
    tmpSymStr = Sym.genSymName T.F

--
-- Emits string such like,
--
--  double tmpVar[2];
--  vst1q_f64(tmpVar, v);
--  double fvar = tmpVar[0];
--
-- Use vst1q_f64 for safety for now,
-- but once it is guaranteed that the address stored is aligned to 16 bytes,
-- we could use _mm_store_pd
-- 
-- TODO: Refactor! Is there any clever way such like template string in
--       Haskell?
--
prtDVtoD :: Sym.Sym -> IR.Exp -> Doc
prtDVtoD sym exp =
  concatD [
    docStr $ strOfType T.D,
    docStr $ tmpSymStr ++ "[2]",
    docStr ";",
    docStr "vst1q_f64",
    docStr "(",
    docStr tmpSymStr,
    docStr ",",
    prtSymOfExpN exp 1,
    docStr ")",
    docStr ";",
    prtSymConstDefN sym 1,
    docStr "=",
    docStr $ tmpSymStr ++ "[0]",
    docStr ";"
  ]

  where

    tmpSymStr :: String
    tmpSymStr = Sym.genSymName T.D

--
-- a      : float32x4_t
-- r0, r1 : float64x2_t
--
-- r0 = vcvt_f64_f32(a)
-- r1 = vcvt_high_f64_f32(a)
--
prtVtoDV :: Sym.Sym -> IR.Exp -> Doc
prtVtoDV sym exp = concatD
  [ prtSymConstDefN sym 1
  , docStr "="
  , docStr "vcvt_f64_f32("
  , prtSymOfExpN exp 1
  , docStr ")"
  , docStr ";"

  --

  , prtSymConstDefN sym 2
  , docStr "="
  , docStr "vcvt_high_f64_f32("
  , prtSymOfExpN exp 1
  , docStr ")"
  , docStr ";"
  ]


--
-- Emits string such like,
--
--  int tmpVar[4];
--  _mm_storeu_si128((int32x4_t *)tmpVar, v);
--  int ivar = tmpVar[0];
--
-- Use _mm_storeu_si128 for safety for now,
-- but once it is guaranteed that the address stored is aligned to 16 bytes,
-- we could use _mm_store_si128
-- 
--
-- TODO: Refactor! Is there any clever way such like template string in
--       Haskell?
--
prtIVtoI :: Sym.Sym -> IR.Exp -> Doc
prtIVtoI sym exp =
  concatD [
    docStr $ strOfType T.I,
    docStr $ tmpSymStr ++ "[4]",
    docStr ";",
    docStr "_mm_storeu_si128",
    docStr "((int32x4_t *)",
    docStr tmpSymStr,
    docStr ",",
    prtSymOfExpN exp 1,
    docStr ")",
    docStr ";",
    prtSymConstDefN sym 1,
    docStr "=",
    docStr $ tmpSymStr ++ "[0]",
    docStr ";"
  ]

  where

    tmpSymStr :: String
    tmpSymStr = Sym.genSymName T.I

--
-- emit code such like,
--
--   float tmp[4];
--   vst1q_f32(tmp, v);
--
prtVtoArray :: T.Typ -> Sym.Sym -> String -> IR.Exp -> Doc
prtVtoArray ty sym tmpStr exp =
  concatD [ docStr $ strOfType ty
          , docStr $ tmpStr ++ "[4]"
          , docStr ";"
          , docStr "vst1q_f32"
          , docStr "("
          , docStr tmpStr
          , docStr ","
          , prtSymOfExpN exp 1
          , docStr ")"
          , docStr ";"
          ]


instance CodeGenNEON IR.Exp where
  prt e = case e of
    -- IR.EIdent sym id     -> concatD [prtSym sym]
    -- IR.ELoad sym (IR.EIdent idSym id) -> concatD
    --   [ prtSymConstDef sym
    --   , docStr "="
    --   , prtAccessIdentSym idSym ReadMode
    --   , docStr ";"
    --   ]
    IR.ELoad sym (IR.EIdent idSym id) ->
      
      emitELoadV sym idSym (vLen sym)

      where

        emitELoadV sym idSym 0 = concatD []
        emitELoadV sym idSym n = concatD
          [ emitELoadV sym idSym (n-1)
          
          --

          , prtSymConstDefN sym n
          , docStr "="
          , prtReadIdentSymN idSym n
          , docStr ";"
          ]

    IR.ELoad sym exp -> concatD
      -- [ prt exp
      -- , prtSymConstDef sym
      -- , docStr "="
      -- , prtSymOfExp exp
      -- , docStr ";"
      -- ]

      [ prt exp
      , emitELoadV sym exp (vLen sym)
      ]

      where

        emitELoadV sym exp 0 = concatD []
        emitELoadV sym exp n = concatD
          [ emitELoadV sym exp (n-1)
          
          --

          , prtSymConstDefN sym n
          , docStr "="
          , prtSymOfExpN exp n
          , docStr ";"
          ]


    IR.EFloat sym val    -> concatD 

      [ prtSymConstDefN sym 1
      , docStr "="
      , docStr $ show val ++ "f"
      , docStr ";"
      ]

    IR.EDouble sym val    -> concatD 

      [ prtSymConstDefN sym 1
      , docStr "="
      , docStr $ show val
      , docStr ";"
      ]

    IR.EInt sym val      -> concatD 

      [ prtSymConstDefN sym 1
      , docStr "="
      , docStr $ showIntVal val
      , docStr ";"
      ]

      where

        showIntVal val = if val > 0 then show val ++ "U"
                                    else show val

    IR.EIdent sym id     -> concatD []    -- Output nothing

    IR.EFtoV  sym exp    -> concatD
    
      [ prt exp
      , prtFtoV sym exp
      ]

    IR.EItoIV sym exp    -> concatD

      [ prt exp
      , prtItoIV sym exp
      ]

    IR.EIVtoI sym exp    -> concatD 

      [ prt exp
      , prtIVtoI sym exp
      ]

    IR.EVtoF  sym exp    -> concatD
      
      [ prt exp
      , prtVtoF sym exp
      ]

    IR.EVtoDV sym exp    -> concatD

      [ prt exp
      , prtVtoDV sym exp
      ]

    IR.EDtoDV  sym exp    -> concatD
    
      [ prt exp
      , prtDtoDVN sym exp (vLen sym)
      ]

    IR.EDVtoD  sym exp    -> concatD
      
      [ prt exp
      , prtDVtoD sym exp
      ]
                                    

    --
    -- bin op
    -- TODO: parameterize bin op str
    --
    IR.EAnd   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vandq_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "vandq_s32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "vandq_f64"    sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: and"

    IR.EOr    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vorrq_f32"     sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "vorrq_s32"  sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "vorrq_f64"     sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: or"
    IR.EXor   sym e0 e1       -> prtBinOpN   "veorq_s32"    sym e0 e1 (vLen sym)
    IR.ENot   sym e0 e1       -> prtBinOp    "_mm_todo_ps"   sym e0 e1 -- TODO
    IR.EEq    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vceq_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "vceq_s32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "vceq_f64"    sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: Eq"

    IR.ENeq   sym e0 e1 -- !eq
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_todo_cmpneq_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_todo_cmpneq_epi32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "_mm_todo_cmpneq_epi32" sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: Neq"

    IR.EGt    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vcgtq_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "vcgtq_s32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "cvgtq_f64"    sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: Gt"

    IR.EGte   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vcge_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> concatD
      
        [ prt e0
        , prt e1
        , prtSymConstDefN sym 1
        , docStr "="
        , docStr "_mm_xor_si128(_mm_set1_epi32(-1), _mm_cmpgt_epi32("
        , prtSymOfExpN e1 1                         -- flipped e0 and e1
        , docStr ","
        , prtSymOfExpN e0 1                         
        , docStr "))"
        , docStr ";"
        ]        

      | otherwise              -> error "TODO: Gte"

    IR.ELt    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vcltq_f32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "vcltq_s32" sym e0 e1 (vLen sym) 
      | (tyOfExp e0) == T.DVec -> prtBinOpN "vcltq_f64" sym e0 e1 (vLen sym)
      | otherwise              -> error $ "TODO: Lt" ++ show e

    IR.ELte   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vclteq_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "vclteq_f64"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> concatD

        [ prt e0
        , prt e1
        , prtSymConstDefN sym 1
        , docStr "="
        , docStr "_mm_xor_si128(_mm_set1_epi32(-1), _mm_cmpgt_epi32("
        , prtSymOfExpN e0 1
        , docStr ","
        , prtSymOfExpN e1 1                         
        , docStr "))"
        , docStr ";"
        ]        

      | otherwise              -> error "TODO: Lte"

    IR.ENeg  sym exp
      | (tyOfExp exp) == T.Vec -> concatD

        [ prt exp
        , prtSymConstDefN sym 1
        , docStr "="
        , docStr "vmulq_f32(vdupq_n_f321(-1.0f), "
        , prtSymOfExpN exp 1
        , docStr ")"
        , docStr ";"
        ]        

      | otherwise              -> error "TODO: Neg"

    IR.ESlElemWise sym e0 e1  -> prtShiftOpN "vshlq_n_s32"  sym e0 e1 (vLen sym)
    IR.ESrElemWise sym e0 e1  -> prtShiftOpN "_mm_srli_epi32"  sym e0 e1 (vLen sym)
    IR.ESlQWord sym e0 e1     -> prtShiftOpN "_mm_slli_si128"  sym e0 e1 (vLen sym)
    IR.ESrQWord sym e0 e1     -> prtShiftOpN "_mm_slri_si128"  sym e0 e1 (vLen sym)

    IR.EAdd   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vaddq_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "vaddq_s32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "vaddq_f64"    sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: add"

    IR.ESub   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "vsubq_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "vsubq_s32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "vsubq_f64"  sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: sub"

    IR.EMul   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN  "vmulq_f32"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN  "vmulq_s32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN  "vmulq_f64"    sym e0 e1 (vLen sym)
      | otherwise              -> error "TODO: mul"

    IR.EDiv   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN  "vdiv_f32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN  "TODO_idiv"  sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN  "vdiv_f64" sym e0 e1 (vLen sym)

    IR.EDivApprox   sym e0 e1 
      | (tyOfExp e0) == T.Vec  -> prtBinOpN  "muda_divapprox_ps" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN  "TODO_idiv"  sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN  "muda_divapprox_pd" sym e0 e1 (vLen sym)

    --
    -- TODO: optimization when constant value is provided for its array index 
    --       e.g. EArray a (EInt 3) -> a[3]
    --

    --
    -- Emit code suck like this:
    --
    --   vtof(idSym[idExp])
    --
    -- Anyway, the generated tree is something confused,
    -- I have to redesgin construction of the tree so that it becomes 
    -- (EFtov (EArray (EIdent) Exp)).
    --
    IR.EArray sym (IR.EFtoV _ (IR.ELoad _ (IR.EIdent idSym _))) idxExp
        -- -> concatD  [ prt idxExp

        --             --
 
        --             , prtSymConstDef sym
        --             , docStr "="
        --             , docStr "vdupq_n_f321( "
        --             , prtSym idSym
        --             , docStr "["
        --             , prtSymOfExp idxExp 
        --             , docStr "]"
        --             , docStr " )"
        --             , docStr ";"

        --             ]

      -> concatD

        [ prt idxExp
        , emitArrayV sym idSym idxExp (vLen sym)
        ]

        where

          emitArrayV sym idSym idxExp 0 = concatD []
          emitArrayV sym idSym idxExp n = concatD

            [ emitArrayV sym idSym idxExp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "vdupq_n_f32( "
            , prtArraySym idSym 
            , docStr "["
            , prtSymOfExpN idxExp n
            , docStr "]"
            , docStr " )"
            , docStr ";"
            ]


    IR.EArray sym (IR.EItoIV _ (IR.ELoad _ (IR.EIdent idSym _))) idxExp
        -- -> concatD  [ prt idxExp

        --             --
 
        --             , prtSymConstDef sym
        --             , docStr "="
        --             , docStr "_mm_set1_epi32( "
        --             , docStr $ (Sym.getName idSym)
        --             , docStr "["
        --             , prtSymOfExp idxExp 
        --             , docStr "]"
        --             , docStr " )"
        --             , docStr ";"

        --             ]

      -> concatD 

        [ prt idxExp
        , emitArrayV sym idSym idxExp (vLen sym)
        ]

        where

          emitArrayV sym idSym idxExp 0 = concatD []
          emitArrayV sym idSym idxExp n = concatD

            [ emitArrayV sym idSym idxExp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "vdupq_n_s32( "
            , docStr $ (Sym.getName idSym)
            , docStr "["
            , prtSymOfExpN idxExp n
            , docStr "]"
            , docStr " )"
            , docStr ";"
            ]

    IR.EArray sym (IR.ELoad _ (IR.EIdent idSym _)) idxExp
      | hasArrayQual idSym -> concatD

        [ prt idxExp
        , emitArrayV sym idSym idxExp (vLen sym)
        ]
        -- [ prt idxExp
        -- , prtSymConstDef sym 
        -- , docStr "="
        -- , prtSym idSym
        -- , docStr "["
        -- , prtSymOfExp idxExp 
        -- , docStr "]"
        -- , docStr ";"
        -- ]

      | otherwise          -> error "TODO"

      where

        hasArrayQual :: Sym.Sym -> Bool
        hasArrayQual sym = any (T.ArrayQual ==) (Sym.getQuals sym)

        emitArrayV sym idSym idxExp 0 = concatD []
        emitArrayV sym idSym idxExp n = concatD

          [ emitArrayV sym idSym idxExp (n-1)
          , prtSymConstDefN sym n
          , docStr "="
          , prtArraySym idSym
          , docStr "["
          , prtSymOfExpN idxExp n
          , docStr "]"
          , docStr ";"
          ] 

    --
    -- Following emitter may not work. Anyway, never come here?
    --
    IR.EArray sym exp idxExp
        -> concatD  [ prt exp
                    , prt idxExp
                    , prtSymConstDef sym
                    , docStr "="
                    , prtSymOfExp exp
                    , docStr "["
                    , prtSymOfExp idxExp 
                    , docStr "]"
                    , docStr ";"
                    ]

    IR.EFunc  sym id exps 

      -> concatD 
      [ concatD $ map prt exps
      , emitFunV sym id exps (vLen sym)
      ]
      
        where
        
          emitFunV sym id exps 0 = concatD []
          emitFunV sym id exps n = case (Sym.getType sym) of
            T.Void -> concatD 
                    [concatD $ map prt exps,
                     docStr (IR.stringFromIdent id),
                     docStr "(",
                     prtFuncArgSymRefsN exps n,
                     docStr ")",
                     docStr ";"
                    ]
            _      -> concatD
                   [emitFunV sym id exps (n-1),
                    --
                    prtSymConstDefN sym n,
                    docStr "=",
                    docStr "(",
                    docStr $ strOfType (Sym.getType sym),
                    docStr ")",
                    docStr (IR.stringFromIdent id),
                    docStr "(",
                    prtFuncArgSymRefsN exps n,
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- TODO: Use same code gen for intrinsic functions.
    --

    IR.EVecInit  sym exps 
      | (length exps) == 1
        -- sym of exp is already vectorized, thus just emit assign.
        -> concatD [concatD $ map prt exps,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    prtFuncArgSymsN exps,
                    docStr ";"
                   ]

      | (length exps) == 4
        -> concatD [concatD $ map prt exps,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "vdupq_n_f32",
                    docStr "(",
                    prtFuncArgSymsWithScalalizationN exps,
                    docStr ")",
                    docStr ";"
                   ]
      | otherwise
        -> error ("vec() with invalid number of args:" ++ (show $ length exps))

    IR.EDVecInit  sym exps 
      | (length exps) == 1 -> concatD
        -- sym of exp is already vectorized, thus just emit assign.
        -- -> concatD [concatD $ map prt exps,
        --             prtSymConstDef sym,
        --             docStr "=",
        --             prtFuncArgSyms exps,
        --             docStr ";"
        --            ]

        [ concatD $ map prt exps
        , emitDVecInitV sym (replicate (vLen sym) (exps !! 0)) (vLen sym)
        ]


      | (length exps) == 4
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    docStr "vdupq_n_f32",
                    docStr "(",
                    prtFuncArgSymsWithScalalization exps,
                    docStr ")",
                    docStr ";"
                   ]
      | otherwise
        -> error ("dvec() with invalid number of args:" ++ (show $ length exps))

        where

          emitDVecInitV _   _    0 = concatD []
          emitDVecInitV sym exps n = concatD

            [ emitDVecInitV sym (rdrop 1 exps) (n-1)
            
            --
            
            , prtSymConstDefN sym n
            , docStr "="
            , prtSymOfExpN ((rtake 1 exps) !! 0) n
            , docStr ";"
            ]

          --
          -- Extract vector element from tail. How many elemets is extracted is
          -- determined by nElem.
          --
          -- e.g.,
          --
          --   exps = [a, b, c, d, e, f]
          --   n    = 2 
          --
          --   then,
          --
          --   rdrop exps = [a, b, c, d]
          --   rtake exps = [e, f]
          --
          rdrop n = reverse . (drop n) . reverse
          rtake n = reverse . (take n) . reverse


    IR.ESel     sym exps -> concatD

      [ prt $ exps !! 0  -- a
      , prt $ exps !! 1  -- b
      , prt $ exps !! 2  -- cond
      , emitSelV sym exps (vLen sym)
      ]
      
        where
        
          emitSelV sym exps 0 = concatD []
          emitSelV sym exps n = concatD

            [ emitSelV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr op
            , docStr "("
            , prtSymOfExpN (exps !! 0) n      -- a
            , docStr ","
            , prtSymOfExpN (exps !! 1) n      -- b
            , docStr ","
            , prtSymOfExpN (exps !! 2) n      -- cond
            , docStr ")"
            , docStr ";"
            ]

            where

              op = case (Sym.getType sym) of
                    T.Vec  -> "muda_sel_ps"
                    T.DVec -> "muda_sel_pd"
                    _      -> error $ "TODO" ++ show e

{-
      case ( concatD [concatD $ map prt exps,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "muda_sel_ps",
                    docStr "(",
                    prtFuncArgSymsN exps,
                    docStr ")",
                    docStr ";"
                   ]
-}

    --
    -- shuffle
    --
    IR.EExtract     sym exps 
        -> concatD [prt $ exps !! 0,      -- expand first elem only
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "_mm_shuffle_ps",
                    docStr "(",
                    prtFuncArgSymsN $ [exps !! 0],
                    docStr ",",
                    prtFuncArgSymsN $ [exps !! 0],
                    docStr ",",
                    prtShuffleConstant $ getConstantInt (exps !! 1),
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- bit
    --
    IR.EBtoV sym (IR.EInt sym' val) 
        -> concatD [prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "(float32x4_t)vdup_n_s32(",
                    docStr $ show val ++ "U",
                    docStr ")",
                    docStr ";"
                   ]

    IR.EBtoV sym exp 
        -> concatD [prt exp,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "(float32x4_t)(",
                    prtSymOfExpN exp 1,
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- itof
    --
    IR.EItoF sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vcvtq_f32_s32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- ftoi(x).
    -- float to integer conversion with truncation.
    --
    IR.EFtoI sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vcvtq_s32_f32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- 1/sqrt(x). Use approximate rsqrt().
    -- TODO: Add one round of Newton-Raphson for finer accuracy?
    --
    IR.ERsqrt sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vrsqrtsq_f32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- frac(x).
    -- 
    --
    IR.EFrac sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vsubq_f32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ", "
                   , docStr "vrndpq_f32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- ceil(x).
    --
    IR.ECeil sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vrndpq_f32("
                   , prtFuncArgSymsN $ [exps !! 0] 
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- floor(x).
    --
    IR.EFloor sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vrndmq_f32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]


    --
    -- trunc(x).
    -- 
    IR.ETrunc sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vrndq_f32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr "))"
                   , docStr ";"
                   ]

    --
    -- round(x).
    -- Round to nearest even
    --
    IR.ERound sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "vrndaq_f32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- min(a, b).
    --
    IR.EMin sym exps
      | (tyOfExp $ exps !! 0) == T.Vec  -> prtBinOpN "vminq_f32" sym (exps !! 0) (exps !! 1) (vLen sym)
      | (tyOfExp $ exps !! 0) == T.DVec -> prtBinOpN "vminq_f64" sym (exps !! 0) (exps !! 1) (vLen sym)
      | otherwise                       -> error $ "TODO" ++ show e

    --
    -- max(a, b).
    --
    IR.EMax sym exps
      | (tyOfExp $ exps !! 0) == T.Vec  -> prtBinOpN "vmaxq_f32" sym (exps !! 0) (exps !! 1) (vLen sym)
      | (tyOfExp $ exps !! 0) == T.DVec -> prtBinOpN "vmaxq_f64" sym (exps !! 0) (exps !! 1) (vLen sym)
      | otherwise                       -> error $ "TODO" ++ show e

    --
    -- gather(a).
    -- Mapped to movemask, i.e., gather MSB bits.
    --

    IR.EGather sym exps
      | (tyOfExp $ exps !! 0) == T.Vec -> concatD

          [ prt $ exps !! 0      -- first elem only
          , prtSymConstDefN sym 1
          , docStr "="
          , docStr "muda_gather_ps("
          , prtFuncArgSymsN [(exps !! 0)]
          , docStr ")"
          , docStr ";"
          ]

      | (tyOfExp $ exps !! 0) == T.DVec -> concatD

          [ prt $ exps !! 0      -- first elem only
          , prtSymConstDefN sym 1
          , docStr "="
          , docStr "muda_gather_pd("
          , prtSymOfExpN (exps !! 0) 1
          , docStr ","
          , prtSymOfExpN (exps !! 0) 2
          , docStr ")"
          , docStr ";"
          ]

    --
    -- all(a).
    -- Mapped to movemask(x) == 0xf.
    -- TODO: insert gather op for DVec support
    --
    IR.EAll sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitAllV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAllV sym exp 0 = concatD []
          emitAllV sym exp n = concatD

            [ emitAllV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "_mm_cmpeq_epi32(_mm_set1_epi32(15), _mm_set1_epi32(_mm_movemask_ps("
            , prtSymOfExpN exp n
            , docStr ")))"
            , docStr ";"
            ]


    --
    -- any(a).
    -- Mapped to movemask(x) != 0x0.
    -- TODO: insert gather op for DVec support
    --
    IR.EAny sym exps -> concatD
      --   -> concatD [ prt $ exps !! 0      -- first elem only
      --              , prtSymConstDef sym
      --              , docStr "="
      --              , docStr "_mm_cmpneq_epi32(_mm_set1_epi32(_mm_movemask_ps("
      --              , prtFuncArgSyms $ [exps !! 0]
      --              , docStr ")), _mm_set1_epi32(0))"
      --              , docStr ";"
      --              ]

      [ prt $ exps !! 0  -- first elem only
      , emitAnyV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAnyV sym exp 0 = concatD []
          emitAnyV sym exp n = concatD

            [ emitAnyV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "_mm_cmpgt_epi32(_mm_set1_epi32(_mm_movemask_ps("
            , prtSymOfExpN exp n
            , docStr ")), _mm_set1_epi32(0))"
            , docStr ";"
            ]

    --
    -- abs(a).
    --
    IR.EAbs sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitAbsV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAbsV sym exp 0 = concatD []
          emitAbsV sym exp n = concatD

            [ emitAbsV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "vabsq_f32("
            , prtSymOfExpN exp n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- log(a).
    -- Mapped to logmu(x)
    -- TODO: DVec support
    --
    IR.ELog sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitLogV sym exps (vLen sym)
      ]
      
        where
        
          emitLogV sym exps 0 = concatD []
          emitLogV sym exps n = concatD

            [ emitLogV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "logmu("
            , prtFuncArgSymRefsN exps n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- fastlog(a).
    -- Mapped to fastlogmu(x)
    -- TODO: DVec support
    --
    IR.EFastLog sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitFastLogV sym exps (vLen sym)
      ]
      
        where
        
          emitFastLogV sym exps 0 = concatD []
          emitFastLogV sym exps n = concatD

            [ emitFastLogV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "fastlogmu("
            , prtFuncArgSymRefsN exps n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- log2(a).
    -- Mapped to log2mu(x)
    -- TODO: DVec support
    --
    IR.ELog2 sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitLog2V sym exps (vLen sym)
      ]
      
        where
        
          emitLog2V sym exps 0 = concatD []
          emitLog2V sym exps n = concatD

            [ emitLog2V sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "log2mu("
            , prtFuncArgSymRefsN exps n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- fastlog2(a).
    -- Mapped to fastlog2mu(x)
    -- TODO: DVec support
    --
    IR.EFastLog2 sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitFastLog2V sym exps (vLen sym)
      ]
      
        where
        
          emitFastLog2V sym exps 0 = concatD []
          emitFastLog2V sym exps n = concatD

            [ emitFastLog2V sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "fastlog2mu("
            , prtFuncArgSymRefsN exps n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- exp(a).
    -- Mapped to expmu(x)
    -- TODO: DVec support
    --
    IR.EExp sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitExpV sym exps (vLen sym)
      ]
      
        where
        
          emitExpV sym exps 0 = concatD []
          emitExpV sym exps n = concatD

            [ emitExpV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "expmu("
            , prtFuncArgSymRefsN exps n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- fastexp(a).
    -- Mapped to fastexpmu(x)
    -- TODO: DVec support
    --
    IR.EFastExp sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitFastExpV sym exps (vLen sym)
      ]
      
        where
        
          emitFastExpV sym exps 0 = concatD []
          emitFastExpV sym exps n = concatD

            [ emitFastExpV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "fastexpmu("
            , prtFuncArgSymRefsN exps n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- sqrt(a).
    -- Mapped to sqrtmu(x)
    -- TODO: DVec support
    --
    IR.ESqrt sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitSqrtV sym exps (vLen sym)
      ]
      
        where
        
          emitSqrtV sym exps 0 = concatD []
          emitSqrtV sym exps n = concatD

            [ emitSqrtV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "sqrtmu("
            , prtFuncArgSymRefsN exps n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- as_vec(a).
    -- Mapped to cast to float32x4_t
    --
    IR.EAsVec sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitAsVecV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAsVecV sym exp 0 = concatD []
          emitAsVecV sym exp n = concatD

            [ emitAsVecV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "(float32x4_t)("
            , prtSymOfExpN exp n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- as_ivec(a).
    -- Mapped to cast to int32x4_t
    --
    IR.EAsIVec sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitAsIVecV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAsIVecV sym exp 0 = concatD []
          emitAsIVecV sym exp n = concatD

            [ emitAsIVecV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "(int32x4_t)("
            , prtSymOfExpN exp n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- struct field selector.
    --
    IR.EFieldSelect sym id exp
        -> concatD [ prt exp
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "("
                   , docStr $ structVarNameFromExp exp ++ "_1"
                   , docStr $ accessorStr (Sym.getQuals $ IR.getSymFromExp exp)
                   , prt id
                   , docStr ")"
                   , docStr ";"
                   ]

      where
        
        structVarNameFromExp :: IR.Exp -> String
        structVarNameFromExp e = case e of

          --
          -- EIdent is always followd by ELoad
          --
          (IR.ELoad sym (IR.EIdent _ _))  -> Sym.getName sym
          (IR.EArray sym _ _)             -> Sym.getName sym 
          _                                   -> error $ "[CodeGenNEON] TODO " ++ show e

        accessorStr :: [T.Qual] -> String
        accessorStr ty = case ty of 
          [T.InputQual]  -> "->"
          [T.OutputQual] -> "->"
          _              -> "."


    --
    -- swizzle op.
    -- Mapped to _mm_shuffle_ps(). 
    -- TODO: DVec support.
    --
    IR.ESwizzle sym swizzleIndex exp -> case (Sym.getType sym) of

      T.DVec -> concatD
        [ prt exp
        , emitShuffleInsnD2 1 sym (swizzleIndex !! 0) (swizzleIndex !! 1) exp
        , emitShuffleInsnD2 2 sym (swizzleIndex !! 2) (swizzleIndex !! 3) exp
        ]

      T.Vec -> concatD 
        [  prt exp
        , prtSymConstDefN sym 1
        , docStr "="
        , docStr "_mm_shuffle_ps("
        , prtSymOfExpN exp 1
        , docStr ","
        , prtSymOfExpN exp 1
        , docStr ","
        , docStr "_MM_SHUFFLE("
        , prtSwizzleIndex swizzleIndex
        , docStr "))"
        , docStr ";"
        ]

          where

            prtSwizzleIndex :: [Int] -> Doc
            prtSwizzleIndex []     = concatD []
            prtSwizzleIndex [d]    = concatD [docStr $ show d]
            prtSwizzleIndex (d:ds) = concatD [docStr $ show d, docStr ",", prtSwizzleIndex ds]

      _ -> error ("[CodeGenNEON] TODO: " ++ (show e))



--
-- print struct field with 16byte-padding for each field.
-- e.g. "int" type field has another 3 ints to align 16 byte.  
--
-- TODO: - Handle struct in struct.
--       - Do much more sophisticated packing.
--
instance CodeGenNEON IR.MDec where
  prt p = case p of
    IR.MDecl ty id structId -> case (getTypeName ty) of
      "int" -> concatD
                       [ prt ty, prt id , docStr ";"
                       , prt ty, prt (mkTmp id "_pad0"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad1"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad2"), docStr ";"
                       ]

      "float" -> concatD
                       [ prt ty, prt id , docStr ";"
                       , prt ty, prt (mkTmp id "_pad0"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad1"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad2"), docStr ";"
                       ]

      "vec" -> concatD
                       [ prt ty, prt id , docStr ";"
                       ]

      "ivec" -> concatD
                       [ prt ty, prt id , docStr ";"
                       ]

      _      -> error "[CodeGenNEON] IR.MDecl: TODO"

    where

      mkTmp :: IR.Ident -> String -> IR.Ident
      mkTmp (IR.Ident id) str = IR.Ident (id ++ str)

      getTypeName :: IR.Typ -> String
      getTypeName (IR.TName (IR.Ident tname)) = tname

instance CodeGenNEON IR.Struc where
  prt s = case s of
    IR.Struct id mdecs -> concatD [ docStr ("typedef struct " ++ mkStructName id)
                                  , docStr "{"
                                  , prt mdecs
                                  , docStr "}"
                                  , prt id
                                  , docStr ";\n\n"
                                  ]

    where
    
      mkStructName :: IR.Ident -> String
      mkStructName (IR.Ident i) = "_" ++ i

  prtList ss = case ss of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]


prtFormalLoader :: IR.FormalDec -> Doc
prtFormalLoader (IR.FormalDecl sym quals ty id) =

  case (isMutable (Sym.getQuals sym)) of

    True -> concatD

      [ emitFormalLoaderN sym (vLen sym) ]

      where

        emitFormalLoaderN sym 0 = concatD []
        emitFormalLoaderN sym n = concatD

          [ emitFormalLoaderN sym (n-1)
          , docStr "const"
          , prt (Sym.getType sym)
          , docStr $ ((Sym.getName sym) ++ "_ld_" ++ show n)
          , docStr "="
          , prtRefFormalSymN sym n
          , docStr ";"
          ]

    False -> concatD []

instance CodeGenNEON IR.Func where
  prt f = case f of
    IR.Fun specs ty id formaldecs stms ->
      concatD [ prt specs
              

              , returnType
              , prt id
              , docStr "("
              , prt formaldecs
              , docStr ")"
              , docStr "{"

              -- emit formal variable loader(for read-only formal vars)

              , concatD $ (map prtFormalLoader formaldecs)

              -- 

              , prt stms


              --

              ,  docStr "}"
              ,  docStr "\n"
              ]

      where
  
        --
        -- Return type doesn't have native type if it is external.
        --
        returnType =  if (isExternal specs) == True
                        then docStr $ T.strOfType (IR.convTypeMUDA ty)
                        else docStr $ strOfType (IR.convTypeMUDA ty)    -- native type
    
  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]

--
-- TODO: Handle qual specfier.
--
instance CodeGenNEON IR.FormalDec where
  prt e = case e of
    IR.FormalDecl sym quals ty id -> concatD

      [ prtFormalTy (Sym.getType sym) (Sym.getQuals sym), prt id]
    


  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, doc (showString ","), prt xs])


--
-- Print header
--
headerString :: String
headerString = unlines
  [ "//"
  , "// The following code is generated by MUDA compiler"
  , "//"
  , "#ifndef MUDAINTRIN_NEON_H"
  , "#define MUDAINTRIN_NEON_H"
  , ""
  , "#include <arm_neon.h>"
  , ""
  , "#ifdef __GNUC__"
  , "#ifndef MUDA_INLINE"
  , "#define MUDA_INLINE        inline"
  , "#endif"
  , "#ifndef MUDA_ALWAYS_INLINE"
  , "#define MUDA_ALWAYS_INLINE __inline__ __attribute__((always_inline))"
  , "#endif"
  , "#ifndef MUDA_STATIC"
  , "#define MUDA_STATIC        static"
  , "#endif"
  , "#else"
  , "#define MUDA_INLINE        __inline"
  , "#define MUDA_ALWAYS_INLINE __inline"
  , "#define MUDA_STATIC        static"
  , "#endif // __GNUC_"
  , ""
  , "//#include \"muda.h\""
  , ""
  , ""
  , "#ifdef __GNUC__"
  , "MUDA_STATIC MUDA_INLINE void *muda_aligned_addr16(void *addr) {"
  , "    return (void *)((((unsigned long long)addr) + 15UL) & ~(15UL));"
  , "}"
  , "#endif"
  , ""
  , "#ifdef __GNUC__"
  , "    #define MUDA_ATTRIB_ALIGN __attribute__((aligned(" ++ align ++ ")))"
  , "    #define MUDA_DECL_ALIGN"
  , "#elif defined(_MSC_VER)"
  , "    #define MUDA_ATTRIB_ALIGN"
  , "    #define MUDA_DECL_ALIGN __declspec(align(" ++ align ++ "))"
  , "#else"
  , "    #error \"Sorry, MUDA doesn't support your compiler\""
  , "#endif"
  , ""
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE float32x4_t muda_sel_ps( const float32x4_t a, const float32x4_t b, const float32x4_t mask )"
  , "{"
  , "    // TODO(syoyo): Use VSEL instruction"
  , "    const uint32x4_t um = vcvtq_u32_f32(mask);"
  , "    const uint32x4_t ua = vcvtq_u32_f32(a);"
  , "    const uint32x4_t ub = vcvtq_u32_f32(b);"
  , "    const uint32x4_t ret = vorrq_u32(vandq_u32((um), (ua)), vandq_u32(vmvnq_u32(um), (ub)));"
  , "    return vcvtq_f32_u32(ret);"
  , "}"
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE float64x2_t muda_sel_pd( const float64x2_t a, const float64x2_t b, const float64x2_t mask )"
  , "{"
  , "    assert(0); "
  , "    return a; // TODO;"
  , "}"
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE int muda_gather_pd( const float64x2_t a, const float64x2_t b )"
  , "{"
  , "    assert(0); "
  , "    return 0; // TODO;"
  , "}"
  , ""
  , "// from AltiVec/NEON migration guide"
  , "// this can be replaced with cvttps2pi?"
  , "MUDA_STATIC MUDA_ALWAYS_INLINE float32x4_t muda_trunc_ps( const float32x4_t x )"
  , "{"
  , "    assert(0); "
  , "    return x; // TODO;"
  , "}"
  , ""
  , "// If we fix rounding mode, the code can be simplified more."
  , "MUDA_STATIC MUDA_ALWAYS_INLINE float32x4_t muda_floor_ps( const float32x4_t x )"
  , "{"
  , "    assert(0); "
  , "    return x; // TODO;"
  , "}"
  , ""
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE float32x4_t muda_ceil_ps( const float32x4_t x )"
  , "{"
  , "    assert(0); "
  , "    return x; // TODO;"
  , "}"
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE float32x4_t muda_divapprox_ps( const float32x4_t a, const float32x4_t x )"
  , "{"
  , "    const float32x4_t recip = vrecpeq_f32(x); "
  , "    const float32x4_t nrecip = vmulq_f32(recip, vrecpsq_f32(recip, x)); "
  , "    return nrecip;"
  , "}"
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE float64x2_t muda_divapprox_pd( const float64x2_t a, const float64x2_t x )"
  , "{"
  , "    assert(0); "
  , "    return a; // TODO;"
  , "}"
  , ""
  , "//#include \"mudamath_neon.h\""
  , ""
  , "#endif // MUDAINTRIN_NEON_H"
  ]
  where
    align = show 16  -- TODO: parameterize

--
-- e.g. _m128 a
--
prtSymDef :: Sym.Sym -> Doc
prtSymDef sym = concatD [prt (Sym.getType sym),
                         doc $ showString $ (Sym.getName sym)
                        ]

prtSymDefN :: Sym.Sym -> Int -> Doc
prtSymDefN sym n = concatD
  [ prt (Sym.getType sym)
  , docStr $ (Sym.getName sym) ++ "_" ++ (show n)
  ]

--
-- e.g. &a
--
prtSymRef:: Sym.Sym -> Doc
prtSymRef sym = concatD [docStr "&(",
                         doc $ showString $ (Sym.getName sym),
                         docStr ")"
                        ]

--
-- e.g. const _m128 a
--
prtSymConstDef :: Sym.Sym -> Doc
prtSymConstDef sym = concatD [docStr "const",
                              prt (Sym.getType sym),
                              docStr (Sym.getName sym)]

prtSymConstDefN :: Sym.Sym -> Int -> Doc
prtSymConstDefN sym n = concatD
  [ docStr "const"
  , prt (Sym.getType sym)
  , docStr $ (Sym.getName sym) ++ "_" ++ (show n)
  ]

prtSymConstDefWithPrefix :: Sym.Sym -> String -> Doc
prtSymConstDefWithPrefix sym prefix = concatD
  [ docStr "const"
  , prt (Sym.getType sym)
  , docStr $ (Sym.getName sym) ++ "_" ++ prefix
  ]

prtVarSym :: Sym.Sym -> Doc
prtVarSym sym = case (Sym.getQuals sym) of
  [T.InputQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  [T.InOutQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  [T.OutputQual] -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  _              -> docStr (Sym.getName sym)

prtVarSymN :: Sym.Sym -> Int -> Doc
prtVarSymN sym n = case (Sym.getQuals sym) of
  [T.InputQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ "_" ++ show n ++ ")"
  [T.InOutQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ "_" ++ show n ++ ")"
  [T.OutputQual] -> docStr $ "(*" ++ (Sym.getName sym) ++ "_" ++ show n ++ ")"
  _              -> docStr $ (Sym.getName sym) ++ "_" ++ show n


prtArrayVarSym :: Sym.Sym -> Doc
prtArrayVarSym sym = case (Sym.getQuals sym) of
  _              -> docStr (Sym.getName sym)

prtSym :: Sym.Sym -> Doc
prtSym sym = case (Sym.getKind sym) of
  -- Sym.KindFormalVariable -> prtRefFormalSym sym
  Sym.KindFormalVariable -> prtReadFormalSym sym
  Sym.KindVariable       -> prtVarSym sym
  _                      -> error $ "[CodeGenNEON] prtSym: TODO: " ++ show sym 

prtSymN :: Sym.Sym -> Int -> Doc
prtSymN sym n = case (Sym.getKind sym) of
  -- Sym.KindFormalVariable -> prtRefFormalSym sym
  Sym.KindFormalVariable -> prtReadFormalSymN sym n
  Sym.KindVariable       -> prtVarSymN sym n
  _                      -> error $ "[CodeGenNEON] prtSym: TODO: " ++ show sym 

prtArraySym :: Sym.Sym -> Doc
prtArraySym sym = case (Sym.getKind sym) of
  Sym.KindFormalVariable -> prtArrayFormalSym sym 
  Sym.KindVariable       -> prtArrayVarSym sym
  _                      -> error $ "[CodeGenNEON] prtArraySym: TODO: " ++ show sym 

--
-- func(float scalar )       //       -> a
-- func(float *scalar)       // ptr   -> (*a)
-- func(const float *vector) //       -> (*a)
-- func(float *vector)       // ptr   -> (*a)
--
prtAccessFormalSym :: Sym.Sym -> Doc
prtAccessFormalSym sym = case (isPointer $ Sym.getQuals sym, isScalar $ Sym.getType sym) of
  (True , True )  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (True , False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (False, True )  -> docStr $ nameWithTypeCast sym
  (False, False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"

  where

    nameWithTypeCast :: Sym.Sym -> String
    nameWithTypeCast sym = case Sym.getType sym of
      T.Vec      -> "((float32x4_t *)(" ++ (Sym.getName sym) ++ "))"
      T.IVec     -> "((int32x4_t *)(" ++ (Sym.getName sym) ++ "))"
      T.DVec     -> "((float64x2_t *)(" ++ (Sym.getName sym) ++ "))"
      T.F        -> (Sym.getName sym)
      T.D        -> (Sym.getName sym)
      T.I        -> (Sym.getName sym)
      T.L        -> (Sym.getName sym)
      T.Var s    -> (Sym.getName sym)

prtAccessFormalSymN :: Sym.Sym -> Int -> Doc
prtAccessFormalSymN sym n = case (isPointer $ Sym.getQuals sym, isScalar $ Sym.getType sym) of
  (True , True )  -> docStr $ "(*" ++ (nameWithTypeCastN sym n) ++ ")"
  (True , False)  -> docStr $ "(*" ++ (nameWithTypeCastN sym n) ++ ")"
  (False, True )  -> docStr $ nameWithTypeCastN sym n
  (False, False)  -> docStr $ "(*" ++ (nameWithTypeCastN sym n) ++ ")"

  where

    nameWithTypeCastN :: Sym.Sym -> Int -> String
    nameWithTypeCastN sym n = case Sym.getType sym of
      T.Vec      -> "((float32x4_t *)("  ++ (Sym.getName sym) ++ "+" ++ show (4 * (n-1)) ++ "))"
      T.IVec     -> "((int32x4_t *)(" ++ (Sym.getName sym) ++ "+" ++ show (4 * (n-1)) ++ "))"
      T.DVec     -> "((float64x2_t *)(" ++ (Sym.getName sym) ++ "+" ++ show (2 * (n-1)) ++ "))"
      T.F        -> (Sym.getName sym)
      T.D        -> (Sym.getName sym)
      T.I        -> (Sym.getName sym)
      T.L        -> (Sym.getName sym)
      T.Var s    -> (Sym.getName sym)

prtReadFormalSym :: Sym.Sym -> Doc
prtReadFormalSym sym = case (isPointer $ Sym.getQuals sym, isScalar $ Sym.getType sym) of
  (True , True )  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (True , False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (False, True )  -> docStr $ ((Sym.getName sym) ++ "_ld")
  (False, False)  -> docStr $ ((Sym.getName sym) ++ "_ld")

  where

    nameWithTypeCast :: Sym.Sym -> String
    nameWithTypeCast sym = case Sym.getType sym of
      T.Vec      -> "((float32x4_t *)(" ++ (Sym.getName sym) ++ "))"
      T.IVec     -> "((int32x4_t *)(" ++ (Sym.getName sym) ++ "))"
      T.DVec     -> "((float64x2_t *)(" ++ (Sym.getName sym) ++ "))"
      T.F        -> (Sym.getName sym)
      T.D        -> (Sym.getName sym)
      T.I        -> (Sym.getName sym)
      T.L        -> (Sym.getName sym)
      T.Var s    -> (Sym.getName sym)

prtReadFormalSymN :: Sym.Sym -> Int -> Doc
prtReadFormalSymN sym n = case (isPointer $ Sym.getQuals sym, isScalar $ Sym.getType sym) of
  (True , True )  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (True , False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (False, True )  -> docStr $ ((Sym.getName sym) ++ "_ld_" ++ show n)
  (False, False)  -> docStr $ ((Sym.getName sym) ++ "_ld_" ++ show n)

  where

    nameWithTypeCast :: Sym.Sym -> String
    nameWithTypeCast sym = case Sym.getType sym of
      T.Vec      -> "((float32x4_t *)(" ++ (Sym.getName sym) ++ "))"
      T.IVec     -> "((int32x4_t *)(" ++ (Sym.getName sym) ++ "))"
      T.DVec     -> "((float64x2_t *)(" ++ (Sym.getName sym) ++ "))"
      T.F        -> (Sym.getName sym)
      T.D        -> (Sym.getName sym)
      T.I        -> (Sym.getName sym)
      T.L        -> (Sym.getName sym)
      T.Var s    -> (Sym.getName sym)

prtRefFormalSym :: Sym.Sym -> Doc
prtRefFormalSym sym = case Sym.getType sym of
  T.Vec      -> docStr $ "vld1q_f32(" ++ (Sym.getName sym) ++ ")"
  T.IVec     -> docStr $ "vld1q_s32(int32_t const *)(" ++ (Sym.getName sym) ++ "))"
  T.DVec     -> docStr $ "((float64x2_t *)(" ++ (Sym.getName sym) ++ "))"
  T.F        -> docStr $ (Sym.getName sym)
  T.I        -> docStr $ (Sym.getName sym)
  T.Var s    -> docStr $ (Sym.getName sym)

prtRefFormalSymN :: Sym.Sym -> Int -> Doc
prtRefFormalSymN sym n = case Sym.getType sym of
  T.Vec      -> docStr $ "vld1q_f32("    ++ (Sym.getName sym) ++ " + " ++ show (4 * (n-1)) ++ ")"
  T.IVec     -> docStr $ "vld1q_s32((int32_t const *)(" ++ (Sym.getName sym) ++ " + " ++ show (4 * (n-1)) ++ "))"
  T.DVec     -> docStr $ "vld1q_f64("    ++ (Sym.getName sym) ++ " + " ++ show (2 * (n-1)) ++ ")"
  T.F        -> docStr $ (Sym.getName sym)
  T.I        -> docStr $ (Sym.getName sym)
  T.Var s    -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"

prtArrayFormalSym :: Sym.Sym -> Doc
prtArrayFormalSym sym = case Sym.getType sym of
  T.Vec      -> docStr $ "((float32x4_t *)(" ++ (Sym.getName sym) ++ "))"
  T.IVec     -> docStr $ "((int32x4_t *)(" ++ (Sym.getName sym) ++ "))"
  T.DVec     -> docStr $ "((float64x2_t *)(" ++ (Sym.getName sym) ++ "))"
  T.F        -> docStr $ (Sym.getName sym)
  T.I        -> docStr $ (Sym.getName sym)
  T.Var s    -> docStr $ (Sym.getName sym)

prtReadIdentSymN :: Sym.Sym -> Int -> Doc
prtReadIdentSymN sym n = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtVarSymN sym n
  Sym.KindFormalVariable -> prtReadFormalSymN sym n 
  _                      -> error $ "[CodeGenNEON] prtAccessIdentSym: TODO: " ++ show sym

prtAssignIdentSymN :: Sym.Sym -> Int -> Doc
prtAssignIdentSymN sym n = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtSymN sym n
  Sym.KindFormalVariable -> prtAccessFormalSymN sym n
  _                      -> error $ "[CodeGenNEON] prtAccessIdentSym: TODO: " ++ show sym

prtAccessIdentSym :: Sym.Sym -> AccessMode -> Doc
prtAccessIdentSym sym ReadMode = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtSym sym
  Sym.KindFormalVariable -> prtReadFormalSym sym 
  _                      -> error $ "[CodeGenNEON] prtAccessIdentSym: TODO: " ++ show sym

prtAccessIdentSym sym AssignMode = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtSym sym
  Sym.KindFormalVariable -> prtAccessFormalSym sym 
  _                      -> error $ "[CodeGenNEON] prtAccessIdentSym: TODO: " ++ show sym

prtSymOfExp :: IR.Exp -> Doc
prtSymOfExp exp = prtSym $ IR.getSymFromExp exp

prtSymOfExpN :: IR.Exp -> Int -> Doc
prtSymOfExpN exp n = prtSymN (IR.getSymFromExp exp) n

docStr :: String -> Doc
docStr str = doc (showString str)

instance CodeGenNEON IR.DecInitExp where
  prt e = case e of
    IR.DExp sym exp          -> concatD [prt exp]

instance CodeGenNEON IR.DecInit where
  prt d = case d of
    IR.DeclInit id []        -> concatD []
    IR.DeclInit id [initExp] -> concatD [prt initExp]
    _                        -> error "???"
    
vLen :: Sym.Sym -> Int
vLen sym = case (Sym.getType sym) of
  T.Vec   -> 1 
  T.IVec  -> 1 
  T.DVec  -> 2 
  T.F     -> 1 
  T.I     -> 1 
  T.D     -> 1 
  T.Var _ -> 1 
  _       -> error $ "vLen: TODO: " ++ show sym

nElem :: Sym.Sym -> Int
nElem sym = case (Sym.getType sym) of
  T.Vec  -> 4 
  T.DVec -> 2 
  T.F    -> 1 
  T.I    -> 1 
  T.D    -> 1 
  _      -> error $ "vLen: TODO: " ++ show sym

instance CodeGenNEON IR.Stm where
  prt e = case e of
    -- IR.SDecl sym ty (IR.DeclInit declid []) ->
    --                              concatD [prtSymDef sym,
    --                                       docStr ";"]

    IR.SDecl sym ty (IR.DeclInit declid []) ->

      emitSDeclV sym (vLen sym) 

      where
  
        emitSDeclV sym 0 = concatD []
        emitSDeclV sym n = concatD
          [ emitSDeclV sym (n - 1)
          , prtSymDefN sym n
          , docStr ";"
          ]

    --IR.SDecl sym ty (IR.DeclInit declid [initExp]) ->
    --                             concatD [prt initExp,
    --                                      prtSymDef sym,
    --                                      docStr "=",
    --                                      prtSym (IR.getSymFromDExp initExp),
    --                                      docStr ";"
    --                                      ]

    IR.SDecl sym ty (IR.DeclInit declid [initExp]) -> concatD

      [ prt initExp
      , emitSDeclWithExpV sym initExp (vLen sym)
      ]

      where
  
        emitSDeclWithExpV sym exp 0 = concatD []
        emitSDeclWithExpV sym exp n = concatD
          [ emitSDeclWithExpV sym exp (n - 1)

          --

          , prtSymDefN sym n
          , docStr "="
          , prtSymN (IR.getSymFromDExp exp) n
          , docStr ";"
          ]


    IR.SAssign sym id exp     -> concatD

      [ prt exp
      , emitAssignV sym exp (vLen sym)
      ]

      where

        emitAssignV sym exp 0 = concatD []
        emitAssignV sym exp n = concatD

          [ emitAssignV sym exp (n-1)
          , prtAssignIdentSymN sym n
          , docStr "="
          , prtSymN (IR.getSymFromExp exp) n
          , docStr ";"

          ]

    --
    -- Use brute force assignment.
    --
    -- a.xy = v is mapped to.
    --
    -- float tmp[4];
    -- vst1q_f32(tmp, v);
    --
    -- ((float *)&a)[0] = tmp[0];
    -- ((float *)&a)[1] = tmp[1];
    --
    --
    -- TODO: Optimize!
    --       - Use shuffle instruction for (length swizzleIndex) == 4 case.
    --       - NEON4 may have partial update instruction.
    --
    IR.SAssignWithSwizzle sym id swizzleIndex exp
        ->  concatD [ prt exp
                    , prtVtoArray T.F sym tmpSymStr exp
                    , prtAssignWithSwizzle swizzleIndex 0 leftSymStr rightSymStr
                    ]
            
            where

              tmpSymStr :: String
              tmpSymStr = Sym.genSymName T.F

              leftSymStr  = Sym.getName sym
              rightSymStr = tmpSymStr 

              prtAssignWithSwizzle :: [Int] -> Int -> String -> String -> Doc

              prtAssignWithSwizzle []     pos lhs rhs = concatD []
              prtAssignWithSwizzle [d]    pos lhs rhs =
                concatD [ prtAssignWithSwizzleOp d pos lhs rhs ]

              prtAssignWithSwizzle (d:ds) pos lhs rhs =
                concatD [ prtAssignWithSwizzleOp d pos lhs rhs
                        , docStr "\n"
                        , prtAssignWithSwizzle ds (pos + 1) lhs rhs
                        ]

              -- TODO: fix me
              prtAssignWithSwizzleOp :: Int -> Int -> String -> String -> Doc
              prtAssignWithSwizzleOp idx pos lhs rhs =
                docStr ("((float *)&" ++ lhs ++ "_1)[" ++ show idx ++ "]" ++
                        " = " ++ rhs ++ "[" ++ show pos ++ "];")
              
  
              
    IR.SAssignWithField sym id fields exp -> concatD

      [ prt exp
      , docStr "("
      , prtAssignIdentSymN sym 1
      , docStr $ accessorStr (Sym.getQuals sym)
      , docStr $ fieldName (fields !! 0)
      , docStr ")"
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"
      ]

      where

        fieldName :: IR.Field -> String
        fieldName (IR.EField (IR.Ident str)) = str
        
        accessorStr :: [T.Qual] -> String
        accessorStr ty = case ty of 
          [T.InputQual]  -> "."
          [T.OutputQual] -> "."
          [T.InOutQual]  -> "."
          _              -> "."


    IR.SAssignWithArray sym id idxExp exp -> concatD

      -- TODO: support DVec

      [ prt idxExp
      , prt exp
      -- , docStr $ (Sym.getName sym)
      , prtArraySym sym
      , docStr "["
      , prtSymOfExpN idxExp 1
      , docStr "]"
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"
      ]


    --
    -- Compound statement. Enclose the statement in parentheses.
    --
    IR.SBlock stms          -> concatD [docStr "{",
                                        prt stms,
                                        docStr "}"]

    --
    -- Do some tricks.
    --
    -- while (exp) { stm }
    --
    -- is converted to,
    --
    -- expand(exp);
    -- flag = root(exp)
    -- while (flag)) {
    --     stm;
    --     expand(exp);
    --     flag = root(exp);
    -- }
    --
    IR.SWhile exp stms      -> concatD

      [ prt exp

      -- Update flag

      , prt T.I
      , docStr flagReg
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"

      --

      , docStr "while"
      , docStr "("
      , docStr flagReg
      , docStr ")"
      , docStr "{"

      , prt stms
      , prt exp

      -- Update flag

      , docStr flagReg
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"

      , docStr "}"
      ]

      where flagReg = mkTempRegFromTy T.I

    IR.SIf exp ifStms elseStms -> concatD

      [ prt exp
      , docStr "if"
      , docStr "("
      , prtSymN (IR.getSymFromExp exp) 1    -- exp should be int scalar.
      , docStr ")"
      , docStr "{"
      , prt ifStms
      , docStr "}"
      , docStr "else"
      , docStr "{"
      , prt elseStms
      , docStr "}"
      ]

    IR.SReturnVoid          -> concatD

      [ docStr "return"
      , docStr "; // void"
      ]

    IR.SReturn exp          -> concatD

      [ prt exp
      , emitReturn exp
      ]

      where

        emitReturn exp = concatD
            
            [ docStr "return"
            , prtSymN (IR.getSymFromExp exp) 1
            , docStr ";"
            ]

        dretReg :: String
        dretReg = Sym.genSymName T.DVec
      
    IR.SExp exp          -> concatD

      [ prt exp
      ]


    _ -> error $ "[CodeGenNEON] TODO: " ++ show e

  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, docStr "\n",  prt xs])


instance CodeGenNEON IR.FuncSpec where
  prt f = case f of
    IR.InlineFuncSpec       -> doc $ showString "MUDA_INLINE"
    IR.ForceInlineFuncSpec  -> doc $ showString "MUDA_INLINE"
    IR.AlwaysInlineFuncSpec -> doc $ showString "MUDA_ALWAYS_INLINE"
    IR.StaticFuncSpec       -> doc $ showString "MUDA_STATIC"

  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]



instance CodeGenNEON IR.Prog where
  prt p = case p of
    IR.Program structs funcs -> concatD [prt structs, prt funcs]




instance CodeGenNEON IR.Ident where
  prt (IR.Ident i) = doc (showString i)

convType :: String -> String
convType s = case s of
  "vec"  -> "float32x4_t"
  "dvec" -> "float64x2_t"
  "ivec" -> "int32x4_t"
  "lvec" -> "int64x2_t" -- TODO
  "int"  -> "int"
  s      -> s

strOfType :: T.Typ -> String
strOfType ty = convType $ T.strOfType ty

instance CodeGenNEON IR.Typ where
  prt (IR.TName e) = case e of
    (IR.Ident tname) -> concatD [doc (showString $ convType tname)] 

instance CodeGenNEON T.Typ where
  prt ty = concatD [doc (showString $ strOfType ty)] 


getConstantInt :: IR.Exp -> Integer
getConstantInt exp = case exp of
  (IR.EItoIV _ (IR.ELoad _ (IR.EInt _ i))) -> i
  _                                        -> error $ "Unknown expression for getConstantInt: " ++ show exp

prtShuffleConstant :: Integer -> Doc
prtShuffleConstant i = 
  concatD [ docStr "_MM_SHUFFLE(",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ")"
          ]


--
-- Emit string to be a header file.
--


prtHeader :: IR.Prog -> Doc
prtHeader p = case p of
  IR.Program structs funcs ->concatD 

    [ docStr commonHeaderString
    , concatD $ map prtHeaderStructDefs structs
    , concatD $ map prtHeaderFuncDefs funcs
    ]

  where

    commonHeaderString = unlines

      [ "//"
      , "// The following code is generated by MUDA compiler"
      , "//"
      , "#include <arm_neon.h>"
      , "\n"
      ]

prtHeaderStructDefs :: IR.Struc -> Doc
prtHeaderStructDefs s = case s of
  IR.Struct id mdecs -> concatD [ docStr ("typedef struct " ++ mkStructName id)
                                , docStr "{"
                                , prt mdecs
                                , docStr "}"
                                , prt id
                                , docStr ";\n\n"
                                ]

    where
    
      mkStructName :: IR.Ident -> String
      mkStructName (IR.Ident i) = "_" ++ i


prtHeaderFuncDefs :: IR.Func -> Doc
prtHeaderFuncDefs p = case p of
  IR.Fun specs ty id formaldecs stms 

    -- Skip functions defined with "MUDA_INLINE" or "MUDA_STATIC" 
    | (length specs) > 0  -> concatD []
    | otherwise           -> concatD

      [ docStr "extern"

      -- Return type doesn't have native type.
      , docStr $ T.strOfType (IR.convTypeMUDA ty)
      , prt id
      , docStr "("

      , prt formaldecs

      , docStr ")"
      , docStr ";"
      , docStr "\n"
      ]


substDoc :: String -> [(String, String)] -> Doc
substDoc t b = concatD $ map (doc . showString) (splitBySpace $ substText t b)

splitBySpace :: String -> [String]
splitBySpace = splitRegex (mkRegex " +")

--
-- Template string in Haskell.
--
--
-- binding = [("reg0", "a")
--           ,("reg1", "b")
--           ]
--
-- substText "[[reg0]] = [[reg1]]" binding
--
--   => "a = b"
--
substText = foldl (\ t (n, v) -> subRegex (mkRegex ("\\[\\[" ++ n ++ "\\]\\]")) t v)




--
-- Remember that x86 is little endian.
-- The order of constant value is c1(i1) and c0(i0).
--
emitShuffleConstantD2 i0 i1 = concatD
  [ docStr "_MM_SHUFFLE2("
  , docStr c1 
  , docStr ","
  , docStr c0
  , docStr ")"
  ]

  where

    c0 = if (even i0) == True then "0" else "1"
    c1 = if (even i1) == True then "0" else "1"

emitShuffleInsnD2 n sym i0 i1 e = concatD
  [ prtSymConstDefN sym n
  , docStr "="
  , docStr "_mm_shuffle_pd("
  , emitExprFromIdx i0 e
  , docStr ", "
  , emitExprFromIdx i1 e
  , docStr ", "
  , emitShuffleConstantD2 i0 i1
  , docStr ")"
  , docStr ";"
  ]

  where

    emitExprFromIdx i e
      | (i < 2)   = concatD [prtSymOfExpN e 1]         -- 0, 1
      | otherwise = concatD [prtSymOfExpN e 2]         -- 2, 3


-- vim: set ts=2 sw=2 expandtab:

