-------------------------------------------------------------------------------
---- |
---- Module      :  CodeGenAVX
---- Copyright   :  (c) Syoyo Fujita
---- License     :  BSD-style
----
---- Maintainer  :  syoyo@lighttransport.com
---- Stability   :  experimental
---- Portability :  GHC 7.6
----
---- CodeGenAVX  :  Code generator for x86 AVX.
----
-------------------------------------------------------------------------------
module CodeGenAVX where

import Debug.Trace
import Text.Regex

import Data.Char
import qualified IR
import qualified Sym
import qualified TypeMUDA as T

-- pretty-printer grabbed from PrintMUDA.hs generated by the BNF converter
-- with small modification.

-- the top-level printing method of the tree
printTree :: (CodeGenAVX a) => a -> String
-- printTree tree = headerString ++ (render $ prt tree)
printTree tree = "#include \"mudaintrin_avx.h\"\n\n" ++(render $ prt tree)

-- the top-level printing method to output the header file
printHeader :: IR.Prog -> String
printHeader tree = (render $ prtHeader tree)

printIntrinsicHeader :: String
printIntrinsicHeader = headerString

type Doc = [ShowS] -> [ShowS]

type Register = String
data AccessMode = ReadMode | AssignMode

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> new i . showChar '{' . new (i+1) . rend (i+1) ts
    -- "} else {" :ts -> trace "else" $ new (i-1) . showString "} else {" . new i . rend i ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    t  : "}" :ts -> showString t . new (i-1) . showString "}" . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    --";"      :ts -> showChar ';' . new i . rend i ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    "\n"     :ts -> new i . rend i ts
    t  : "," :ts -> showString t . space "," . rend i ts
    t  : ")" :ts -> showString t . showString ") " . rend i ts
    t  : "]" :ts -> showString t . showChar ']' . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  --new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile isSpace
  new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile (\x -> x == ' ')
  -- new2 ii  = trace "new2" $ showChar '\n'
  space t = showString t . (\s -> if null s then "" else (' ':s))

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

instance CodeGenAVX Char where
  prt s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

--
-- CodeGenAVX class
--

class CodeGenAVX a where
  prt :: a -> Doc
  prtList :: [a] -> Doc
  prtList = concatD . map prt


instance CodeGenAVX a => CodeGenAVX [a] where
  prt = prtList


--
-- TODO: If this routine will not used, remove.
--
isVector :: T.Typ -> Bool
isVector ty
  | ty == T.Vec  = True
  | ty == T.IVec = True 
  | otherwise    = False 

isScalar :: T.Typ -> Bool
isScalar ty
  | ty == T.F  = True
  | ty == T.I  = True 
  | otherwise  = False 

isPointer :: [T.Qual] -> Bool
isPointer q 
  | any (T.InOutQual  ==) q = True
  | any (T.OutputQual ==) q = True
  | any (T.ArrayQual  ==) q = True
  | otherwise               = False

isMutable :: [T.Qual] -> Bool
isMutable q 
  | any (T.InOutQual  ==) q = False
  | any (T.OutputQual ==) q = False
  | any (T.ArrayQual  ==) q = False
  | otherwise               = True

isExternal :: [IR.FuncSpec] -> Bool
isExternal s
  | any (IR.StaticFuncSpec ==)       s = False
  | any (IR.InlineFuncSpec ==)       s = False
  | any (IR.ForceInlineFuncSpec ==)  s = False
  | any (IR.AlwaysInlineFuncSpec ==) s = False
  | otherwise                          = True


tyOfExp :: IR.Exp -> T.Typ
tyOfExp = Sym.getType . IR.getSymFromExp


mkTempRegFromTy :: T.Typ -> Register
mkTempRegFromTy ty =
  Sym.getName (Sym.genSym ty [] Sym.KindVariable)



prtBinOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtBinOp opStr sym e0 e1 = concatD [
  prt e0,
  prt e1,
  prtSymConstDef sym,
  docStr " = ",
  docStr (opStr ++ "("),
  prtSymOfExp e0,
  docStr ", ",
  prtSymOfExp e1, 
  docStr " )",
  docStr ";"
  ]

prtBinOpN :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Int -> Doc
prtBinOpN opStr sym e0 e1 n = concatD 
  [ prt e0
  , prt e1
  , emitBinOpN opStr sym e0 e1 n
  ]

  where

  emitBinOpN _     _   _  _  0 = concatD [] 

  emitBinOpN opStr sym e0 e1 n = concatD 
    [ emitBinOpN opStr sym e0 e1 (n-1)
    , substDoc "[[rhs]] = [[op]]([[e0]], [[e1]]) ;" binding
    ]

  binding = [ ("rhs", render $ prtSymConstDefN sym n)
            , ("op" , opStr)
            , ("e0" , render $ prtSymOfExpN e0 n)
            , ("e1" , render $ prtSymOfExpN e1 n)
            ]

prtCmpOp :: String -> String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtCmpOp opStr cmpStr sym e0 e1 = concatD [
    prt e0
  , prt e1
  , prtSymConstDefN sym 1
  , docStr " = "
  , docStr (opStr ++ "(")
  , prtSymOfExpN e0 1
  , docStr ", "
  , prtSymOfExpN e1 1
  , docStr ", "
  , docStr cmpStr
  , docStr " )"
  , docStr ";"
  ]

--
-- e1 for shift op should be EItoIV (EInt val)
--
prtShiftOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtShiftOp opStr sym e0 (IR.EItoIV _ intExp) = concatD
  [ prt e0
  , prt intExp
  , prtSymConstDef sym
  , docStr " = "
  , docStr ("(__m128)" ++ opStr ++ "((__m128i)")
  , prtSymOfExp e0
  , docStr ", "
  , prtSymOfExp intExp
  , docStr ")" 
  , docStr ";"
  ]

-- TODO
prtShiftOpN :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Int -> Doc
prtShiftOpN opStr sym e0 (IR.EItoIV _ intExp) n = concatD
  [ prt e0
  , prt intExp
  , prtSymConstDefN sym 1
  , docStr " = "
  , docStr (castStr ++ opStr ++ "((__m128i)")
  , prtSymOfExpN e0 1
  , docStr ", "
  , prtSymOfExpN intExp 1
  , docStr ")" 
  , docStr ";"
  ]

  where

    castStr = case (Sym.getType sym) of
      T.Vec -> "(__m128)"
      _     -> ""

--
-- Division by reciprocal + one round of Newton-Raphson
--
-- 1 / v :=  rcp = _mm_rcp_ps(v)
--           return _mm_sub_ps(_mm_add_ps(rcp, rcp),
--                             _mm_mul_ps(_mm_mul_ps(rcp, rcp), v));
--
-- a / v :=  a * (1 / v)
--            
prtApproxDivOp :: Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtApproxDivOp sym e0 e1 = concatD
  [ prt e0
  , prt e1
  , docStr $ "const __m128 " ++ rcpRegName
  , docStr " = "
  , docStr "_mm_rcp_ps("
  , prtSymOfExpN e1 1
  , docStr ")" 
  , docStr ";"
  , docStr $ "const __m128 " ++ tmpRegName
  , docStr " = "
  , docStr $ "_mm_sub_ps(_mm_add_ps(" ++ rcpRegName ++ ", " ++ rcpRegName ++ "), _mm_mul_ps(_mm_mul_ps(" ++ rcpRegName ++ ", " ++ rcpRegName ++ "), "
  , prtSymOfExpN e1 1
  , docStr "))"
  , docStr ";"
  , prtSymConstDefN sym 1
  , docStr " = "
  , docStr "_mm_mul_ps("
  , prtSymOfExpN e0 1
  , docStr ","
  , docStr tmpRegName
  , docStr ")"
  , docStr ";"
  ]

  where
  
    rcpRegName = show (Sym.getType $ IR.getSymFromExp e1) ++ (Sym.getName $ IR.getSymFromExp e1) ++ "_rcp"
    tmpRegName = rcpRegName ++ "_tmp"

--
-- Not is mapped to _mm_andnot_ps(x, 0xffffffff)
--                  -> ~x & 0xffffffff
--                  -> ~x
--
prtNotOp sym exp = concatD
  [ prt exp
  , prtSymConstDef sym
  , docStr "="
  , docStr "_mm_andnot_ps("
  , prtSymOfExp exp
  , docStr ","
  , docStr "(__m128)_mm_set1_epi32(0xffffffff)"
  , docStr ")"
  , docStr ";"
  ]


prtFormalTy :: T.Typ -> [T.Qual] -> Doc
prtFormalTy t qs = case (t, isPointer qs) of
  (T.Vec  , True ) -> concatD[ docStr "float *" ]
  (T.F    , True ) -> concatD[ docStr "float *" ]
  (T.DVec , True ) -> concatD[ docStr "double *" ]
  (T.D    , True ) -> concatD[ docStr "double *" ]
  (T.IVec , True ) -> concatD[ docStr "int *" ]
  (T.I    , True ) -> concatD[ docStr "int *" ]
  (T.LVec , True ) -> concatD[ docStr "long long *" ]
  (T.L    , True ) -> concatD[ docStr "long long *" ]
  (T.Vec  , False) -> concatD[ docStr "const float *" ]
  (T.F    , False) -> concatD[ docStr "const float" ]
  (T.DVec , False) -> concatD[ docStr "const double *" ]
  (T.D    , False) -> concatD[ docStr "const double" ]
  (T.IVec , False) -> concatD[ docStr "const int *" ]
  (T.I    , False) -> concatD[ docStr "const int" ]
  (T.LVec , False) -> concatD[ docStr "const long long *" ]
  (T.L    , False) -> concatD[ docStr "const long long" ]
  (T.Var s, True ) -> concatD[ docStr $ s ++ " *" ]
  (T.Var s, False) -> concatD[ docStr $ "const " ++ s ++ " *" ]


prtFuncArgSyms :: [IR.Exp] -> Doc
prtFuncArgSyms []     = concatD []
prtFuncArgSyms [e]    = concatD [prtSymOfExp e]
prtFuncArgSyms (e:es) = concatD [prtSymOfExp e, docStr ",", prtFuncArgSyms es]

prtFuncArgSymsN :: [IR.Exp] -> Doc
prtFuncArgSymsN []     = concatD []
prtFuncArgSymsN [e]    = concatD
  [ emitFuncArgSymsV e (vLen (IR.getSymFromExp e))]

prtFuncArgSymsN (e:es) = concatD 
  [ emitFuncArgSymsV e (vLen (IR.getSymFromExp e))
  , docStr ","
  , prtFuncArgSymsN es
  ]

emitFuncArgSymsV :: IR.Exp -> Int -> Doc
emitFuncArgSymsV exp 0 = concatD []
emitFuncArgSymsV exp n = concatD
  [ emitFuncArgSymsV exp (n-1)
  , prtSymOfExpN exp n
  ]


prtFuncArgSymsWithScalalization (e:es) = concatD [prtSymOfExp e, docStr ",", prtFuncArgSyms es]

prtFuncArgSymsWithScalalizationN (e:es) = concatD [prtSymOfExpN e 1, docStr ",", prtFuncArgSymsN es]

prtTypecastForFuncArg :: Sym.Sym -> Doc
prtTypecastForFuncArg sym = case (Sym.getType sym) of
  T.Vec  -> concatD [ docStr "(float *)" ]  
  T.DVec -> concatD [ docStr "(double *)" ]  
  T.IVec -> concatD [ docStr "(int *)" ]  
  _      -> concatD [] 

prtFuncArgSymRefs :: [IR.Exp] -> Doc
prtFuncArgSymRefs []     = concatD []
prtFuncArgSymRefs [e]    = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                   , docStr "&(", prtSymOfExp e, docStr ")"
                                   ]
prtFuncArgSymRefs (e:es) = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                   , docStr "&(", prtSymOfExp e, docStr "),"
                                   , prtFuncArgSymRefs es
                                   ]

prtFuncArgSymRefsN :: [IR.Exp] -> Doc
prtFuncArgSymRefsN []     = concatD []
prtFuncArgSymRefsN [e]    = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                    , docStr "&(", prtSymOfExpN e 1, docStr ")"
                                    ]
prtFuncArgSymRefsN (e:es) = concatD [ prtTypecastForFuncArg (IR.getSymFromExp e)
                                    , docStr "&(", prtSymOfExpN e 1, docStr "),"
                                    , prtFuncArgSymRefsN es
                                    ]


prtFtoV :: Sym.Sym -> IR.Exp -> Doc
prtFtoV sym exp = concatD

    [ prtSymConstDefN sym 1
    , docStr "="
    , docStr "_mm_set_ps1( "
    , prtSymOfExpN exp 1
    , docStr " )"
    , docStr ";"
    ]

prtDtoDV :: Sym.Sym -> IR.Exp -> Doc
prtDtoDV sym exp = concatD

    [ prtSymConstDefN sym 1
    , docStr "="
    , docStr "_mm256_set_pd( "
    , prtSymOfExpN exp 1
    , docStr ","
    , prtSymOfExpN exp 1
    , docStr ","
    , prtSymOfExpN exp 1
    , docStr ","
    , prtSymOfExpN exp 1
    , docStr " )"
    , docStr ";"
    ]

prtItoIV :: Sym.Sym -> IR.Exp -> Doc
prtItoIV sym exp = concatD

    [ prtSymConstDefN sym 1
    , docStr "="
    , docStr "_mm_set1_epi32( "
    , prtSymOfExpN exp 1
    , docStr " )"
    , docStr ";"
    ]

--
-- Emits string such like,
--
--  float tmpVar[4];
--  _mm_storeu_ps(tmpVar, v);
--  float fvar = tmpVar[0];
--
-- Use _mm_storeu_ps for safety for now,
-- but once it is guaranteed that the address stored is aligned to 16 bytes,
-- we could use _mm_store_ps
-- 
--
-- TODO: Refactor! Is there any clever way such like template string in
--       Haskell?
--
prtVtoF :: Sym.Sym -> IR.Exp -> Doc
prtVtoF sym exp =
  concatD [
    docStr $ strOfType T.F,
    docStr $ tmpSymStr ++ "[4]",
    docStr ";",
    docStr "_mm_storeu_ps",
    docStr "(",
    docStr tmpSymStr,
    docStr ",",
    prtSymOfExpN exp 1,
    docStr ")",
    docStr ";",
    prtSymConstDefN sym 1,
    docStr "=",
    docStr $ tmpSymStr ++ "[0]",
    docStr ";"
  ]

  where

    tmpSymStr :: String
    tmpSymStr = Sym.genSymName T.F

--
-- a      : __m128
-- r0, r1 : __m128d
--
-- r0 = _mm_cvtps_pd(a)
-- r1 = _mm_cvtps_pd(_mm_movehl_ps(a, a))
--
prtVtoDV :: Sym.Sym -> IR.Exp -> Doc
prtVtoDV sym exp = concatD
  [ prtSymConstDefN sym 1
  , docStr "="
  , docStr "_mm_cvtps_pd("
  , prtSymOfExpN exp 1
  , docStr ")"
  , docStr ";"

  --

  , prtSymConstDefN sym 2
  , docStr "="
  , docStr "_mm_cvtps_pd(_mm_movehl_ps("
  , prtSymOfExpN exp 1
  , docStr ","
  , prtSymOfExpN exp 1
  , docStr "))"
  , docStr ";"
  ]


--
-- Emits string such like,
--
--  int tmpVar[4];
--  _mm_storeu_si128((__m128i *)tmpVar, v);
--  int ivar = tmpVar[0];
--
-- Use _mm_storeu_si128 for safety for now,
-- but once it is guaranteed that the address stored is aligned to 16 bytes,
-- we could use _mm_store_si128
-- 
--
-- TODO: Refactor! Is there any clever way such like template string in
--       Haskell?
--
prtIVtoI :: Sym.Sym -> IR.Exp -> Doc
prtIVtoI sym exp =
  concatD [
    docStr $ strOfType T.I,
    docStr $ tmpSymStr ++ "[4]",
    docStr ";",
    docStr "_mm_storeu_si128",
    docStr "((__m128i *)",
    docStr tmpSymStr,
    docStr ",",
    prtSymOfExpN exp 1,
    docStr ")",
    docStr ";",
    prtSymConstDefN sym 1,
    docStr "=",
    docStr $ tmpSymStr ++ "[0]",
    docStr ";"
  ]

  where

    tmpSymStr :: String
    tmpSymStr = Sym.genSymName T.I

--
-- emit code such like,
--
--   float tmp[4];
--   _mm_storeu_ps(tmp, v);
--
prtVtoArray :: T.Typ -> Sym.Sym -> String -> IR.Exp -> Doc
prtVtoArray ty sym tmpStr exp =
  concatD [ docStr $ strOfType ty
          , docStr $ tmpStr ++ "[4]"
          , docStr ";"
          , docStr "_mm_storeu_ps"
          , docStr "("
          , docStr tmpStr
          , docStr ","
          , prtSymOfExpN exp 1
          , docStr ")"
          , docStr ";"
          ]


instance CodeGenAVX IR.Exp where
  prt e = case e of
    -- IR.EIdent sym id     -> concatD [prtSym sym]
    -- IR.ELoad sym (IR.EIdent idSym id) -> concatD
    --   [ prtSymConstDef sym
    --   , docStr "="
    --   , prtAccessIdentSym idSym ReadMode
    --   , docStr ";"
    --   ]
    IR.ELoad sym (IR.EIdent idSym id) ->
      
      emitELoadV sym idSym (vLen sym)

      where

        emitELoadV sym idSym 0 = concatD []
        emitELoadV sym idSym n = concatD
          [ emitELoadV sym idSym (n-1)
          
          --

          , prtSymConstDefN sym n
          , docStr "="
          , prtReadIdentSymN idSym n
          , docStr ";"
          ]

    IR.ELoad sym exp -> concatD
      -- [ prt exp
      -- , prtSymConstDef sym
      -- , docStr "="
      -- , prtSymOfExp exp
      -- , docStr ";"
      -- ]

      [ prt exp
      , emitELoadV sym exp (vLen sym)
      ]

      where

        emitELoadV sym exp 0 = concatD []
        emitELoadV sym exp n = concatD
          [ emitELoadV sym exp (n-1)
          
          --

          , prtSymConstDefN sym n
          , docStr "="
          , prtSymOfExpN exp n
          , docStr ";"
          ]


    IR.EFloat sym val    -> concatD [prtSymConstDefN sym 1,
                                     docStr "=",
                                     docStr $ show val,
                                     docStr ";"]

    IR.EDouble sym val    -> concatD [prtSymConstDefN sym 1,
                                      docStr "=",
                                      docStr $ show val,
                                      docStr ";"]

    IR.EInt sym val      -> concatD [prtSymConstDefN sym 1,
                                     docStr "=",
                                     docStr $ show val,
                                     docStr ";"]

    IR.EIdent sym id     -> concatD []    -- Output nothing

    IR.EFtoV  sym exp    -> concatD
    
      [ prt exp
      , prtFtoV sym exp
      ]

    IR.EDtoDV  sym exp    -> concatD
    
      [ prt exp
      , prtDtoDV sym exp
      ]

    IR.EItoIV sym exp    -> concatD

      [ prt exp
      , prtItoIV sym exp
      ]

    IR.EIVtoI sym exp    -> concatD 

      [ prt exp
      , prtIVtoI sym exp
      ]

    IR.EVtoF  sym exp    -> concatD
      
      [ prt exp
      , prtVtoF sym exp
      ]

    IR.EVtoDV sym exp    -> concatD

      [ prt exp
      , prtVtoDV sym exp
      ]
                                    

    --
    -- bin op
    -- TODO: parameterize bin op str
    --
    IR.EAnd   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_and_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_and_si128" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "_mm256_and_pd" sym e0 e1 (vLen sym)
      | otherwise              -> error $ "TODO" ++ (show e)

    IR.EOr    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_or_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_or_si128" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "_mm256_or_pd" sym e0 e1 (vLen sym)
      | otherwise              -> error $ "TODO" ++ (show e)

    IR.EXor   sym e0 e1       -> prtBinOpN   "_mm_xor_ps"    sym e0 e1 (vLen sym)
    IR.ENot   sym e0 e1       -> prtBinOp    "_mm_todo_ps"   sym e0 e1 -- TODO
    IR.EEq    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_cmpeq_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_cmpeq_epi32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "_mm_cmpeq_pd"    sym e0 e1 (vLen sym)
      | otherwise              -> error $ "TODO" ++ (show e)

    IR.ENeq   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_cmpneq_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_cmpneq_epi32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "_mm_cmpneq_epi32" sym e0 e1 (vLen sym)
      | otherwise              -> error  $ "TODO" ++ (show e)

    IR.EGt    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_cmpgt_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_cmpgt_epi32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtCmpOp "_mm256_cmp_pd" "_CMP_GT_OQ" sym e0 e1
      | otherwise              -> error $ "TODO" ++ (show e)

    IR.EGte   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_cmpge_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> concatD
      
        [ prt e0
        , prt e1
        , prtSymConstDefN sym 1
        , docStr "="
        , docStr "_mm_xor_si128(_mm_set1_epi32(-1), _mm_cmpgt_epi32("
        , prtSymOfExpN e1 1                         -- flipped e0 and e1
        , docStr ","
        , prtSymOfExpN e0 1                         
        , docStr "))"
        , docStr ";"
        ]        

      | (tyOfExp e0) == T.DVec -> prtCmpOp "_mm256_cmp_pd" "_CMP_GE_OQ" sym e0 e1
      | otherwise              -> error  $ "TODO" ++ (show e)

    IR.ELt    sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_cmplt_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_cmpgt_epi32" sym e1 e0 (vLen sym) -- Flipped.
      | (tyOfExp e0) == T.DVec -> prtCmpOp "_mm256_cmp_pd" "_CMP_LT_OQ" sym e0 e1
      | otherwise              -> error $ "TODO" ++ (show e)

    IR.ELte   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_cmple_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> concatD

        [ prt e0
        , prt e1
        , prtSymConstDefN sym 1
        , docStr "="
        , docStr "_mm_xor_si128(_mm_set1_epi32(-1), _mm_cmpgt_epi32("
        , prtSymOfExpN e0 1
        , docStr ","
        , prtSymOfExpN e1 1                         
        , docStr "))"
        , docStr ";"
        ]        

      | (tyOfExp e0) == T.DVec -> prtCmpOp "_mm256_cmp_pd" "_CMP_LE_OQ" sym e0 e1

      | otherwise              -> error  $ "TODO" ++ (show e)

    IR.ENeg  sym exp
      | (tyOfExp exp) == T.Vec -> concatD
        [ prt exp
        , prtSymConstDefN sym 1
        , docStr "="
        , docStr "_mm_mul_ps(_mm_set_ps1(-1.0f), "
        , prtSymOfExpN exp 1
        , docStr ")"
        , docStr ";"
        ]        

      | otherwise              -> error  $ "TODO" ++ (show e)

    IR.ESlElemWise sym e0 e1  -> prtShiftOpN "_mm_slli_epi32"  sym e0 e1 (vLen sym)
    IR.ESrElemWise sym e0 e1  -> prtShiftOpN "_mm_srli_epi32"  sym e0 e1 (vLen sym)
    IR.ESlQWord sym e0 e1     -> prtShiftOpN "_mm_slli_si128"  sym e0 e1 (vLen sym)
    IR.ESrQWord sym e0 e1     -> prtShiftOpN "_mm_slri_si128"  sym e0 e1 (vLen sym)

    IR.EAdd   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_add_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_add_epi32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "_mm256_add_pd" sym e0 e1 (vLen sym)
      | otherwise              -> error  $ "TODO" ++ (show e)

    IR.ESub   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN "_mm_sub_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN "_mm_sub_epi32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN "_mm256_sub_pd"  sym e0 e1 (vLen sym)
      | otherwise              -> error  $ "TODO" ++ (show e)

    IR.EMul   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN  "_mm_mul_ps"    sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN  "_mm_mul_epi32" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN  "_mm256_mul_pd"    sym e0 e1 (vLen sym)
      | otherwise              -> error  $ "TODO" ++ (show e)

    IR.EDiv   sym e0 e1
      | (tyOfExp e0) == T.Vec  -> prtBinOpN  "_mm_div_ps" sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.IVec -> prtBinOpN  "TODO_idiv"  sym e0 e1 (vLen sym)
      | (tyOfExp e0) == T.DVec -> prtBinOpN  "_mm256_div_pd" sym e0 e1 (vLen sym)

    --
    -- There's no builtin approximate division for double precision.
    -- Usually, native division in double precision is sufficiently fast.
    IR.EDivApprox   sym e0 e1
      | (tyOfExp e0) == T.DVec -> prtBinOpN  "muda_divapprox_pd" sym e0 e1 (vLen sym)
    --
    -- TODO: optimization when constant value is provided for its array index 
    --       e.g. EArray a (EInt 3) -> a[3]
    --

    --
    -- Emit code suck like this:
    --
    --   vtof(idSym[idExp])
    --
    -- Anyway, the generated tree is something confused,
    -- I have to redesgin construction of the tree so that it becomes 
    -- (EFtov (EArray (EIdent) Exp)).
    --
    IR.EArray sym (IR.EFtoV _ (IR.ELoad _ (IR.EIdent idSym _))) idxExp
        -- -> concatD  [ prt idxExp

        --             --
 
        --             , prtSymConstDef sym
        --             , docStr "="
        --             , docStr "_mm_set_ps1( "
        --             , prtSym idSym
        --             , docStr "["
        --             , prtSymOfExp idxExp 
        --             , docStr "]"
        --             , docStr " )"
        --             , docStr ";"

        --             ]

      -> concatD

        [ prt idxExp
        , emitArrayV sym idSym idxExp (vLen sym)
        ]

        where

          emitArrayV sym idSym idxExp 0 = concatD []
          emitArrayV sym idSym idxExp n = concatD

            [ emitArrayV sym idSym idxExp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "_mm_set_ps1( "
            , prtArraySym idSym 
            , docStr "["
            , prtSymOfExpN idxExp n
            , docStr "]"
            , docStr " )"
            , docStr ";"
            ]


    IR.EArray sym (IR.EItoIV _ (IR.ELoad _ (IR.EIdent idSym _))) idxExp
        -- -> concatD  [ prt idxExp

        --             --
 
        --             , prtSymConstDef sym
        --             , docStr "="
        --             , docStr "_mm_set1_epi32( "
        --             , docStr $ (Sym.getName idSym)
        --             , docStr "["
        --             , prtSymOfExp idxExp 
        --             , docStr "]"
        --             , docStr " )"
        --             , docStr ";"

        --             ]

      -> concatD 

        [ prt idxExp
        , emitArrayV sym idSym idxExp (vLen sym)
        ]

        where

          emitArrayV sym idSym idxExp 0 = concatD []
          emitArrayV sym idSym idxExp n = concatD

            [ emitArrayV sym idSym idxExp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "_mm_set1_epi32( "
            , docStr $ (Sym.getName idSym)
            , docStr "["
            , prtSymOfExpN idxExp n
            , docStr "]"
            , docStr " )"
            , docStr ";"
            ]

    IR.EArray sym (IR.ELoad _ (IR.EIdent idSym _)) idxExp
      | hasArrayQual idSym -> concatD

        [ prt idxExp
        , emitArrayV sym idSym idxExp (vLen sym)
        ]
        -- [ prt idxExp
        -- , prtSymConstDef sym 
        -- , docStr "="
        -- , prtSym idSym
        -- , docStr "["
        -- , prtSymOfExp idxExp 
        -- , docStr "]"
        -- , docStr ";"
        -- ]

      | otherwise          -> error "TODO"

      where

        hasArrayQual :: Sym.Sym -> Bool
        hasArrayQual sym = any (T.ArrayQual ==) (Sym.getQuals sym)

        emitArrayV sym idSym idxExp 0 = concatD []
        emitArrayV sym idSym idxExp n = concatD

          [ emitArrayV sym idSym idxExp (n-1)
          , prtSymConstDefN sym n
          , docStr "="
          , prtArraySym idSym
          , docStr "["
          , prtSymOfExpN idxExp n
          , docStr "]"
          , docStr ";"
          ] 

    --
    -- Following emitter may not work. Anyway, never come here?
    --
    IR.EArray sym exp idxExp
        -> concatD  [ prt exp
                    , prt idxExp
                    , prtSymConstDef sym
                    , docStr "="
                    , prtSymOfExp exp
                    , docStr "["
                    , prtSymOfExp idxExp 
                    , docStr "]"
                    , docStr ";"
                    ]

    IR.EFunc  sym id exps 
      | (Sym.getType sym) == T.Void
        -> concatD [concatD $ map prt exps,
                    docStr (IR.stringFromIdent id),
                    docStr "(",
                    prtFuncArgSymRefsN exps,
                    docStr ")",
                    docStr ";"]
      | otherwise
        -> concatD [concatD $ map prt exps,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "(",
                    docStr $ strOfType (Sym.getType sym),
                    docStr ")",
                    docStr (IR.stringFromIdent id),
                    docStr "(",
                    prtFuncArgSymRefsN exps,
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- TODO: Use same code gen for intrinsic functions.
    --

    IR.EVecInit  sym exps 
      | (length exps) == 1
        -- sym of exp is already vectorized, thus just emit assign.
        -> concatD [concatD $ map prt exps,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    prtFuncArgSymsN exps,
                    docStr ";"
                   ]

      | (length exps) == 4
        -> concatD [concatD $ map prt exps,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "_mm_set_ps",
                    docStr "(",
                    prtFuncArgSymsWithScalalizationN exps,
                    docStr ")",
                    docStr ";"
                   ]
      | otherwise
        -> error ("vec() with invalid number of args:" ++ (show $ length exps))

    IR.EDVecInit  sym exps 
      | (length exps) == 1 -> concatD
        -- sym of exp is already vectorized, thus just emit assign.
        -- -> concatD [concatD $ map prt exps,
        --             prtSymConstDef sym,
        --             docStr "=",
        --             prtFuncArgSyms exps,
        --             docStr ";"
        --            ]

        [ concatD $ map prt exps
        , emitDVecInitV sym (replicate (vLen sym) (exps !! 0)) (vLen sym)
        ]


      | (length exps) == 4
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    docStr "_mm_set_ps",
                    docStr "(",
                    prtFuncArgSymsWithScalalization exps,
                    docStr ")",
                    docStr ";"
                   ]
      | otherwise
        -> error ("dvec() with invalid number of args:" ++ (show $ length exps))

        where

          emitDVecInitV _   _    0 = concatD []
          emitDVecInitV sym exps n = concatD

            [ emitDVecInitV sym (rdrop 1 exps) (n-1)
            
            --
            
            , prtSymConstDefN sym n
            , docStr "="
            , prtSymOfExpN ((rtake 1 exps) !! 0) n
            , docStr ";"
            ]

          --
          -- Extract vector element from tail. How many elemets is extracted is
          -- determined by nElem.
          --
          -- e.g.,
          --
          --   exps = [a, b, c, d, e, f]
          --   n    = 2 
          --
          --   then,
          --
          --   rdrop exps = [a, b, c, d]
          --   rtake exps = [e, f]
          --
          rdrop n = reverse . (drop n) . reverse
          rtake n = reverse . (take n) . reverse


    IR.ESel     sym exps 
        -> concatD [concatD $ map prt exps,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr $ insn (exps !! 0),
                    docStr "(",
                    prtFuncArgSymsN exps,
                    docStr ")",
                    docStr ";"
                   ]

            where
      
              insn exp = case (tyOfExp exp) of
                T.DVec -> "_mm256_blendv_pd"

    --
    -- shuffle
    --
    IR.EExtract     sym exps 
        -> concatD [prt $ exps !! 0,      -- expand first elem only
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "_mm_shuffle_ps",
                    docStr "(",
                    prtFuncArgSymsN $ [exps !! 0],
                    docStr ",",
                    prtFuncArgSymsN $ [exps !! 0],
                    docStr ",",
                    prtShuffleConstant $ getConstantInt (exps !! 1),
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- bit
    --
    IR.EBtoV sym (IR.EInt sym' val) 
        -> concatD [prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "(__m128)_mm_set1_epi32(",
                    docStr $ show val ++ "U",
                    docStr ")",
                    docStr ";"
                   ]

    IR.EBtoV sym exp 
        -> concatD [prt exp,
                    prtSymConstDefN sym 1,
                    docStr "=",
                    docStr "(__m128)(",
                    prtSymOfExpN exp 1,
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- itof
    --
    IR.EItoF sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "_mm_cvtepi32_ps((__m128i)"
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- ftoi(x).
    -- float to integer conversion with truncation.
    --
    IR.EFtoI sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "(__m128i)_mm_cvttps_epi32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- 1/sqrt(x). Use div(sqrt(x)).
    -- FIXME: DVec only
    --
    IR.ERsqrt sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "_mm256_div_pdl(_mm256_set_pd(1.0, 1.0, 1.0, 1.0), _mm256_sqrt_pd("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr "))"
                   , docStr ";"
                   ]

    --
    -- frac(x).
    -- Mapped to muda_frac_ps(x).
    -- 
    --
    IR.EFrac sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "_mm_sub_ps("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ", "
                   , docStr "muda_ceil_ps("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- ceil(x).
    -- Mapped to muda_ceil_ps().
    -- 
    -- NOTE: AVX4 has _mm_ceil_ps() intrinsic function?.
    --
    IR.ECeil sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "muda_ceil_ps("
                   , prtFuncArgSymsN $ [exps !! 0] 
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- floor(x).
    -- Mapped to muda_floor_ps().
    -- 
    -- NOTE: AVX4 has _mm_floor_ps() intrinsic function?.
    --
    IR.EFloor sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "muda_floor_ps("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr ")"
                   , docStr ";"
                   ]


    --
    -- trunc(x).
    -- 
    -- NOTE: AVX4 has _mm_trunc_ps() intrinsic function.
    --
    IR.ETrunc sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "_mm_cvtepi32_ps(_mm_cvttps_epi32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr "))"
                   , docStr ";"
                   ]

    --
    -- round(x).
    -- Mapped to itof(ftoi(x)) = _mm_cvtepi32_ps(_mm_cvtps_epi32(x)).
    -- Assume rounding mode is set to round-to-nearest.
    -- 
    -- NOTE: Assume default rounding mode, i.e. round-to-nearest.    
    -- NOTE: AVX4 has _mm_round_ps() intrinsic function.
    --
    IR.ERound sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "_mm_cvtepi32_ps(_mm_cvtps_epi32("
                   , prtFuncArgSymsN $ [exps !! 0]
                   , docStr "))"
                   , docStr ";"
                   ]

    --
    -- min(a, b).
    --
    IR.EMin sym exps  -> prtBinOpN "_mm_min_ps" sym (exps !! 0) (exps !! 1) (vLen sym)

    --
    -- max(a, b).
    --
    IR.EMax sym exps  -> prtBinOpN "_mm_max_ps" sym (exps !! 0) (exps !! 1) (vLen sym)

    --
    -- gather(a).
    -- Mapped to movemask, i.e., gather MSB bits.
    --

    IR.EGather sym exps
        -> concatD [ prt $ exps !! 0      -- first elem only
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "_mm_movemask_ps("
                   , prtFuncArgSymsN [(exps !! 0)]
                   , docStr ")"
                   , docStr ";"
                   ]

    --
    -- all(a).
    -- Mapped to movemask(x) == 0xf.
    -- TODO: insert gather op for DVec support
    --
    IR.EAll sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitAllV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAllV sym exp 0 = concatD []
          emitAllV sym exp n = concatD

            [ emitAllV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "_mm_cmpeq_epi32(_mm_set1_epi32(15), _mm_set1_epi32(_mm_movemask_ps("
            , prtSymOfExpN exp n
            , docStr ")))"
            , docStr ";"
            ]


    --
    -- any(a).
    -- Mapped to movemask(x) != 0x0.
    -- TODO: insert gather op for DVec support
    --
    IR.EAny sym exps -> concatD
      --   -> concatD [ prt $ exps !! 0      -- first elem only
      --              , prtSymConstDef sym
      --              , docStr "="
      --              , docStr "_mm_cmpneq_epi32(_mm_set1_epi32(_mm_movemask_ps("
      --              , prtFuncArgSyms $ [exps !! 0]
      --              , docStr ")), _mm_set1_epi32(0))"
      --              , docStr ";"
      --              ]

      [ prt $ exps !! 0  -- first elem only
      , emitAnyV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAnyV sym exp 0 = concatD []
          emitAnyV sym exp n = concatD

            [ emitAnyV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "_mm_cmpgt_epi32(_mm_set1_epi32(_mm_movemask_ps("
            , prtSymOfExpN exp n
            , docStr ")), _mm_set1_epi32(0))"
            , docStr ";"
            ]

    --
    -- abs(a).
    -- Mapped to muda_abs_ps(x)
    -- TODO: insert gather op for DVec support
    --
    IR.EAbs sym exps 
      | (tyOfExp (exps !! 0)) == T.DVec  -> concatD

        [ prt $ exps !! 0  -- first elem only
        , emitAbsV sym (exps !! 0) (vLen sym)
        ]
        
          where
          
            emitAbsV sym exp 0 = concatD []
            emitAbsV sym exp n = concatD

              [ emitAbsV sym exp (n-1)
              , prtSymConstDefN sym n
              , docStr "="
              , docStr "muda_abs_pd("
              , prtSymOfExpN exp n
              , docStr ")"
              , docStr ";"
              ]


    --
    -- log(a).
    -- Mapped to logmu(x)
    -- TODO: DVec support
    --
    IR.ELog sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitLogV sym exps (vLen sym)
      ]
      
        where
        
          emitLogV sym exps 0 = concatD []
          emitLogV sym exps n = concatD

            [ emitLogV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "logmu("
            , prtFuncArgSymRefsN exps
            , docStr ")"
            , docStr ";"
            ]

    --
    -- fastlog(a).
    -- Mapped to fastlogmu(x)
    -- TODO: DVec support
    --
    IR.EFastLog sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitFastLogV sym exps (vLen sym)
      ]
      
        where
        
          emitFastLogV sym exps 0 = concatD []
          emitFastLogV sym exps n = concatD

            [ emitFastLogV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "fastlogmu("
            , prtFuncArgSymRefsN exps
            , docStr ")"
            , docStr ";"
            ]

    --
    -- log2(a).
    -- Mapped to log2mu(x)
    -- TODO: DVec support
    --
    IR.ELog2 sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitLog2V sym exps (vLen sym)
      ]
      
        where
        
          emitLog2V sym exps 0 = concatD []
          emitLog2V sym exps n = concatD

            [ emitLog2V sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "log2mu("
            , prtFuncArgSymRefsN exps
            , docStr ")"
            , docStr ";"
            ]

    --
    -- fastlog2(a).
    -- Mapped to fastlog2mu(x)
    -- TODO: DVec support
    --
    IR.EFastLog2 sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitFastLog2V sym exps (vLen sym)
      ]
      
        where
        
          emitFastLog2V sym exps 0 = concatD []
          emitFastLog2V sym exps n = concatD

            [ emitFastLog2V sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "fastlog2mu("
            , prtFuncArgSymRefsN exps
            , docStr ")"
            , docStr ";"
            ]

    --
    -- exp(a).
    -- Mapped to expmu(x)
    -- TODO: DVec support
    --
    IR.EExp sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitExpV sym exps (vLen sym)
      ]
      
        where
        
          emitExpV sym exps 0 = concatD []
          emitExpV sym exps n = concatD

            [ emitExpV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr $ insn (exps !! 0) ++ "("
            , prtFuncArgSymRefsN exps
            , docStr ")"
            , docStr ";"
            ]

            where

              insn exp = case (tyOfExp exp) of
                T.DVec -> "expmud"
                 

    --
    -- fastexp(a).
    -- Mapped to fastexpmu(x)
    -- TODO: DVec support
    --
    IR.EFastExp sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitFastExpV sym exps (vLen sym)
      ]
      
        where
        
          emitFastExpV sym exps 0 = concatD []
          emitFastExpV sym exps n = concatD

            [ emitFastExpV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "fastexpmu("
            , prtFuncArgSymRefsN exps
            , docStr ")"
            , docStr ";"
            ]

    --
    -- sqrt(a).
    -- Mapped to _mm256_sqrt_pd(x)
    -- FIXME: DVec only
    --
    IR.ESqrt sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitSqrtV sym exps (vLen sym)
      ]
      
        where
        
          emitSqrtV sym exps 0 = concatD []
          emitSqrtV sym exps n = concatD

            [ emitSqrtV sym exps (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "_mm256_sqrt_pd("
            , prtFuncArgSymRefsN exps
            , docStr ")"
            , docStr ";"
            ]

    --
    -- as_vec(a).
    -- Mapped to cast to __m128
    --
    IR.EAsVec sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitAsVecV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAsVecV sym exp 0 = concatD []
          emitAsVecV sym exp n = concatD

            [ emitAsVecV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "(__m128)("
            , prtSymOfExpN exp n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- as_ivec(a).
    -- Mapped to cast to __m128i
    --
    IR.EAsIVec sym exps -> concatD

      [ prt $ exps !! 0  -- first elem only
      , emitAsIVecV sym (exps !! 0) (vLen sym)
      ]
      
        where
        
          emitAsIVecV sym exp 0 = concatD []
          emitAsIVecV sym exp n = concatD

            [ emitAsIVecV sym exp (n-1)
            , prtSymConstDefN sym n
            , docStr "="
            , docStr "(__m128i)("
            , prtSymOfExpN exp n
            , docStr ")"
            , docStr ";"
            ]

    --
    -- struct field selector.
    --
    IR.EFieldSelect sym id exp
        -> concatD [ prt exp
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "("
                   , docStr $ structVarNameFromExp exp ++ "_1"
                   , docStr $ accessorStr (Sym.getQuals $ IR.getSymFromExp exp)
                   , prt id
                   , docStr ")"
                   , docStr ";"
                   ]

      where
        
        structVarNameFromExp :: IR.Exp -> String
        structVarNameFromExp e = case e of

          --
          -- EIdent is always followd by ELoad
          --
          (IR.ELoad sym (IR.EIdent _ _))  -> Sym.getName sym
          (IR.EArray sym _ _)             -> Sym.getName sym 
          _                                   -> error $ "[CodeGenAVX] TODO " ++ show e

        accessorStr :: [T.Qual] -> String
        accessorStr ty = case ty of 
          [T.InputQual]  -> "->"
          [T.OutputQual] -> "->"
          _              -> "."


    --
    -- swizzle op.
    -- Mapped to _mm_shuffle_ps(). 
    -- TODO: DVec support.
    --
    IR.ESwizzle sym swizzleIndex exp

        -> concatD [ prt exp
                   , prtSymConstDefN sym 1
                   , docStr "="
                   , docStr "_mm_shuffle_ps("
                   , prtSymOfExpN exp 1
                   , docStr ","
                   , prtSymOfExpN exp 1
                   , docStr ","
                   , docStr "_MM_SHUFFLE("
                   , prtSwizzleIndex swizzleIndex
                   , docStr "))"
                   , docStr ";"
                   ]

          where

            prtSwizzleIndex :: [Int] -> Doc
            prtSwizzleIndex []     = concatD []
            prtSwizzleIndex [d]    = concatD [docStr $ show d]
            prtSwizzleIndex (d:ds) = concatD [docStr $ show d, docStr ",", prtSwizzleIndex ds]

    _ -> error ("[CodeGenAVX] TODO: " ++ (show e))



--
-- print struct field with 16byte-padding for each field.
-- e.g. "int" type field has another 3 ints to align 16 byte.  
--
-- TODO: - Handle struct in struct.
--       - Do much more sophisticated packing.
--
instance CodeGenAVX IR.MDec where
  prt p = case p of
    IR.MDecl ty id structId -> case (getTypeName ty) of
      "int" -> concatD
                       [ prt ty, prt id , docStr ";"
                       , prt ty, prt (mkTmp id "_pad0"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad1"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad2"), docStr ";"
                       ]

      "float" -> concatD
                       [ prt ty, prt id , docStr ";"
                       , prt ty, prt (mkTmp id "_pad0"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad1"), docStr ";"
                       , prt ty, prt (mkTmp id "_pad2"), docStr ";"
                       ]

      "vec" -> concatD
                       [ prt ty, prt id , docStr ";"
                       ]

      "ivec" -> concatD
                       [ prt ty, prt id , docStr ";"
                       ]

      _      -> error "[CodeGenAVX] IR.MDecl: TODO"

    where

      mkTmp :: IR.Ident -> String -> IR.Ident
      mkTmp (IR.Ident id) str = IR.Ident (id ++ str)

      getTypeName :: IR.Typ -> String
      getTypeName (IR.TName (IR.Ident tname)) = tname

instance CodeGenAVX IR.Struc where
  prt s = case s of
    IR.Struct id mdecs -> concatD [ docStr ("typedef struct " ++ mkStructName id)
                                  , docStr "{"
                                  , prt mdecs
                                  , docStr "}"
                                  , prt id
                                  , docStr ";\n\n"
                                  ]

    where
    
      mkStructName :: IR.Ident -> String
      mkStructName (IR.Ident i) = "_" ++ i

  prtList ss = case ss of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]


prtFormalLoader :: IR.FormalDec -> Doc
prtFormalLoader (IR.FormalDecl sym quals ty id) =

  case (isMutable (Sym.getQuals sym)) of

    True -> concatD

      [ emitFormalLoaderN sym (vLen sym) ]

      where

        emitFormalLoaderN sym 0 = concatD []
        emitFormalLoaderN sym n = concatD

          [ emitFormalLoaderN sym (n-1)
          , docStr "const"
          , prt (Sym.getType sym)
          , docStr $ ((Sym.getName sym) ++ "_ld_" ++ show n)
          , docStr "="
          , prtRefFormalSymN sym n
          , docStr ";"
          ]

    False -> concatD []

instance CodeGenAVX IR.Func where
  prt f = case f of
    IR.Fun specs ty id formaldecs stms ->
      concatD [ prt specs
              

              , returnType
              , prt id
              , docStr "("
              , prt formaldecs
              , docStr ")"
              , docStr "{"

              -- emit formal variable loader(for read-only formal vars)

              , concatD $ (map prtFormalLoader formaldecs)

              -- 

              , prt stms


              --

              ,  docStr "}"
              ,  docStr "\n"
              ]

      where
  
        --
        -- Return type doesn't have native type if it is external.
        --
        returnType =  if (isExternal specs) == True
                        then docStr $ T.strOfType (IR.convTypeMUDA ty)
                        else docStr $ strOfType (IR.convTypeMUDA ty)    -- native type
    
  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]

--
-- TODO: Handle qual specfier.
--
instance CodeGenAVX IR.FormalDec where
  prt e = case e of
    IR.FormalDecl sym quals ty id -> concatD

      [ prtFormalTy (Sym.getType sym) (Sym.getQuals sym), prt id]
    


  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, doc (showString ","), prt xs])


--
-- Print header
--
headerString :: String
headerString = unlines
  [ "//"
  , "// The following code is generated by MUDA compiler"
  , "//"
  , "#ifndef MUDAINTRIN_AVX_H"
  , "#define MUDAINTRIN_AVX_H"
  , ""
  , "#include <immintrin.h>"
  , ""
  , "#ifdef __GNUC__"
  , "#ifndef MUDA_INLINE"
  , "#define MUDA_INLINE        inline"
  , "#endif"
  , "#ifndef MUDA_ALWAYS_INLINE"
  , "#define MUDA_ALWAYS_INLINE __inline__ __attribute__((always_inline))"
  , "#endif"
  , "#ifndef MUDA_STATIC"
  , "#define MUDA_STATIC        static"
  , "#endif"
  , "#else"
  , "#define MUDA_INLINE        __inline"
  , "#define MUDA_ALWAYS_INLINE __inline"
  , "#define MUDA_STATIC        static"
  , "#endif // __GNUC_"
  , ""
  , "#include \"muda.h\""
  , ""
  , "#ifdef __64bit__"
  , "    #error \"64bit env is not yet supported\""
  , "#else"
  , "#endif"
  , ""
  , ""
  , "#ifdef __GNUC__"
  , "MUDA_STATIC MUDA_INLINE void *muda_aligned_addr16(void *addr) {"
  , "    return (void *)((((unsigned int)addr) + 15UL) & ~(15UL));"
  , "}"
  , "#endif"
  , ""
  , "#ifdef __GNUC__"
  , "    #define MUDA_ATTRIB_ALIGN __attribute__((aligned(" ++ align ++ ")))"
  , "    #define MUDA_DECL_ALIGN"
  , "#elif defined(_MSC_VER)"
  , "    #define MUDA_ATTRIB_ALIGN"
  , "    #define MUDA_DECL_ALIGN __declspec(align(" ++ align ++ "))"
  , "#else"
  , "    #error \"Sorry, MUDA doesn't support your compiler\""
  , "#endif"
  , ""
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE __m128 muda_sel_ps( const __m128 a, const __m128 b, const __m128 mask )"
  , "{"
  , "#ifdef __AVX41__"
  , "    return _mm_blend_ps(a, b, mask);"
  , "#else"
  , "    const __m128 tmp0 = _mm_and_ps( b, mask );"
  , "    const __m128 tmp1 = _mm_andnot_ps( mask, a);"
  , "    return _mm_or_ps( tmp1, tmp0 );"
  , "#endif"
  , "}"
  , ""
  , "// from AltiVec/AVX migration guide"
  , "// this can be replaced with cvttps2pi?"
  , "MUDA_STATIC MUDA_ALWAYS_INLINE __m128 muda_trunc_ps( const __m128 x )"
  , "{"
  , "    const __m128 twoTo23 = (__m128)_mm_set1_epi32(0x4b000000); // 2**23"
  , "    const __m128 b = (__m128)_mm_srli_epi32(_mm_slli_epi32( (__m128i)x, 1), 1); // fabs(x) "
  , "    const __m128 d = _mm_sub_ps(_mm_add_ps( b, twoTo23), twoTo23);" 
  , "    const __m128 largeMaskE = _mm_cmpgt_ps( b, twoTo23); // -1 if x>= 2**23" 
  , "    const __m128 g = _mm_cmplt_ps( b, d );"
  , "    const __m128 h = _mm_cvtepi32_ps( (__m128i)g ); // -1.0 or 0.0"
  , "    const __m128 t = _mm_add_ps( d, h );"
  , "    const __m128 sign = (__m128)_mm_slli_epi32( _mm_srli_epi32( (__m128i)x, 31), 31);"
  , "    const __m128 tt = _mm_or_ps( t, sign );"
  , "    const __m128 vv = _mm_and_ps( x, largeMaskE );"
  , "    const __m128 ttt = _mm_andnot_ps( largeMaskE, tt );"
  , "    return _mm_or_ps( ttt, vv );"
  , "}"
  , ""
  , "// If we fix rounding mode, the code can be simplified more."
  , "MUDA_STATIC MUDA_ALWAYS_INLINE __m128 muda_floor_ps( const __m128 x )"
  , "{"
  , "    const __m128 twoTo23 = (__m128)_mm_set1_epi32(0x4b000000); // 2**23"
  , "    const __m128 b = (__m128)_mm_srli_epi32(_mm_slli_epi32( (__m128i)x, 1), 1); // fabs(x) "
  , "    const __m128 d = _mm_sub_ps(_mm_add_ps(_mm_add_ps(_mm_sub_ps( x, twoTo23), twoTo23), twoTo23), twoTo23); // the meat of floor"
  , "    const __m128 largeMaskE = _mm_cmpgt_ps( b, twoTo23); // -1 if x>= 2**23" 
  , "    const __m128 g = _mm_cmplt_ps( b, d );"
  , "    const __m128 h = _mm_cvtepi32_ps( (__m128i)g );"
  , "    const __m128 t = _mm_add_ps( d, h );"
  , "    const __m128 sign = (__m128)_mm_slli_epi32( _mm_srli_epi32( (__m128i)x, 31), 31);"
  , "    const __m128 tt = _mm_or_ps( t, sign );"
  , "    const __m128 vv = _mm_and_ps( x, largeMaskE );"
  , "    const __m128 ttt = _mm_andnot_ps( largeMaskE, tt );"
  , "    return _mm_or_ps( ttt, vv );"
  , "}"
  , ""
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE __m128 muda_ceil_ps( const __m128 x )"
  , "{"
  , "    const __m128 twoTo23 = (__m128)_mm_set1_epi32(0x4b000000); // 2**23"
  , "    const __m128 one = _mm_set1_ps(1.0f);"
  , "    const __m128 b = (__m128)_mm_srli_epi32(_mm_slli_epi32( (__m128i)x, 1), 1); // fabs(x) "
  , "    const __m128 d = _mm_sub_ps(_mm_add_ps(_mm_add_ps(_mm_sub_ps( x, twoTo23), twoTo23), twoTo23), twoTo23); // the meat of ceil" 
  , "    const __m128 largeMaskE = _mm_cmpgt_ps( b, twoTo23); // -1 if x>= 2**23" 
  , "    const __m128 g = _mm_cmpgt_ps( b, d );"
  , "    const __m128 h = _mm_cvtepi32_ps( (__m128i)g );"
  , "    const __m128 t = _mm_sub_ps( d, h );"
  , "    const __m128 sign = (__m128)_mm_slli_epi32( _mm_srli_epi32( (__m128i)x, 31), 31);"
  , "    const __m128 tt = _mm_or_ps( t, sign );"
  , "    const __m128 vv = _mm_and_ps( x, largeMaskE );"
  , "    const __m128 ttt = _mm_andnot_ps( largeMaskE, tt );"
  , "    return _mm_or_ps( ttt, vv );"
  , "}"
  , ""
  , "// TODO: Using and is faster than 2 shift ops?"
  , "MUDA_STATIC MUDA_ALWAYS_INLINE __m128 muda_abs_ps( const __m128 x )"
  , "{"
  , "    const __m128 b = (__m128)_mm_srli_epi32(_mm_slli_epi32( (__m128i)x, 1), 1); // fabs(x) "
  , "    return b;"
  , "}"
  , ""
  , "// C99 compatible round() function."
  , "// i.e., Round to nearest integer value. If the input value lies"
  , "// exactly halfway between two integer value, round away from zero."
  , "//"
  , "// TODO: Handle NaN case?"
  , "MUDA_STATIC MUDA_ALWAYS_INLINE __m128 muda_round_ps( const __m128 x )"
  , "{"
  , "    const __m128 b = (__m128)_mm_srli_epi32(_mm_slli_epi32( (__m128i)x, 1), 1); // fabs(x) "
  , "    const __m128 t = muda_ceil_ps( b );" 
  , "    const __m128 mask = _mm_cmpgt_ps(_mm_sub_ps( t, x ), _mm_set1_ps( 0.5f ));"
  , "    const __m128 tt = muda_sel_ps( t, _mm_sub_ps( t, _mm_set1_ps(1.0f) ), mask); // if (t - x > 0.5) t -= 1.0"
  , "    const __m128 sign = (__m128)_mm_slli_epi32( _mm_srli_epi32( (__m128i)x, 31), 31);"
  , "    return _mm_xor_ps( tt, sign ); // if (x < 0.0) -t else t"
  , "}"
  , ""
  , "MUDA_STATIC MUDA_ALWAYS_INLINE __m256d muda_divapprox_pd( const __m256d a, const __m256d x )"
  , "{"
  , "    __m256d b = _mm256_cvtps_pd(_mm_rcp_ps(_mm256_cvtpd_ps(x))); "
  , "    b = _mm256_sub_pd(_mm256_add_pd(b, b), _mm256_mul_pd(_mm256_mul_pd(x, b), b)); "
  , "    b = _mm256_sub_pd(_mm256_add_pd(b, b), _mm256_mul_pd(_mm256_mul_pd(x, b), b)); "
  , "    return _mm256_mul_pd(a, b); // = a * (1.0 / x)"
  , "}"
  , "//#include \"mudamath_avx.h\""
  , ""
  , "#endif // MUDAINTRIN_AVX_H"
  ]
  where
    align = show 16  -- TODO: parameterize

--
-- e.g. _m128 a
--
prtSymDef :: Sym.Sym -> Doc
prtSymDef sym = concatD [prt (Sym.getType sym),
                         doc $ showString $ (Sym.getName sym)
                        ]

prtSymDefN :: Sym.Sym -> Int -> Doc
prtSymDefN sym n = concatD
  [ prt (Sym.getType sym)
  , docStr $ (Sym.getName sym) ++ "_" ++ (show n)
  ]

--
-- e.g. &a
--
prtSymRef:: Sym.Sym -> Doc
prtSymRef sym = concatD [docStr "&(",
                         doc $ showString $ (Sym.getName sym),
                         docStr ")"
                        ]

--
-- e.g. const _m128 a
--
prtSymConstDef :: Sym.Sym -> Doc
prtSymConstDef sym = concatD [docStr "const",
                              prt (Sym.getType sym),
                              docStr (Sym.getName sym)]

prtSymConstDefN :: Sym.Sym -> Int -> Doc
prtSymConstDefN sym n = concatD
  [ docStr "const"
  , prt (Sym.getType sym)
  , docStr $ (Sym.getName sym) ++ "_" ++ (show n)
  ]

prtSymConstDefWithPrefix :: Sym.Sym -> String -> Doc
prtSymConstDefWithPrefix sym prefix = concatD
  [ docStr "const"
  , prt (Sym.getType sym)
  , docStr $ (Sym.getName sym) ++ "_" ++ prefix
  ]

prtVarSym :: Sym.Sym -> Doc
prtVarSym sym = case (Sym.getQuals sym) of
  [T.InputQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  [T.InOutQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  [T.OutputQual] -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  _              -> docStr (Sym.getName sym)

prtVarSymN :: Sym.Sym -> Int -> Doc
prtVarSymN sym n = case (Sym.getQuals sym) of
  [T.InputQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ "_" ++ show n ++ ")"
  [T.InOutQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ "_" ++ show n ++ ")"
  [T.OutputQual] -> docStr $ "(*" ++ (Sym.getName sym) ++ "_" ++ show n ++ ")"
  _              -> docStr $ (Sym.getName sym) ++ "_" ++ show n


prtArrayVarSym :: Sym.Sym -> Doc
prtArrayVarSym sym = case (Sym.getQuals sym) of
  _              -> docStr (Sym.getName sym)

prtSym :: Sym.Sym -> Doc
prtSym sym = case (Sym.getKind sym) of
  -- Sym.KindFormalVariable -> prtRefFormalSym sym
  Sym.KindFormalVariable -> prtReadFormalSym sym
  Sym.KindVariable       -> prtVarSym sym
  _                      -> error $ "[CodeGenAVX] prtSym: TODO: " ++ show sym 

prtSymN :: Sym.Sym -> Int -> Doc
prtSymN sym n = case (Sym.getKind sym) of
  -- Sym.KindFormalVariable -> prtRefFormalSym sym
  Sym.KindFormalVariable -> prtReadFormalSymN sym n
  Sym.KindVariable       -> prtVarSymN sym n
  _                      -> error $ "[CodeGenAVX] prtSym: TODO: " ++ show sym 

prtArraySym :: Sym.Sym -> Doc
prtArraySym sym = case (Sym.getKind sym) of
  Sym.KindFormalVariable -> prtArrayFormalSym sym 
  Sym.KindVariable       -> prtArrayVarSym sym
  _                      -> error $ "[CodeGenAVX] prtArraySym: TODO: " ++ show sym 

--
-- func(float scalar )       //       -> a
-- func(float *scalar)       // ptr   -> (*a)
-- func(const float *vector) //       -> (*a)
-- func(float *vector)       // ptr   -> (*a)
--
prtAccessFormalSym :: Sym.Sym -> Doc
prtAccessFormalSym sym = case (isPointer $ Sym.getQuals sym, isScalar $ Sym.getType sym) of
  (True , True )  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (True , False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (False, True )  -> docStr $ nameWithTypeCast sym
  (False, False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"

  where

    nameWithTypeCast :: Sym.Sym -> String
    nameWithTypeCast sym = case Sym.getType sym of
      T.Vec      -> "((__m128 *)(" ++ (Sym.getName sym) ++ "))"
      T.IVec     -> "((__m128i *)(" ++ (Sym.getName sym) ++ "))"
      T.DVec     -> "((__m256d *)(" ++ (Sym.getName sym) ++ "))"
      T.F        -> (Sym.getName sym)
      T.D        -> (Sym.getName sym)
      T.I        -> (Sym.getName sym)
      T.L        -> (Sym.getName sym)
      T.Var s    -> (Sym.getName sym)


prtReadFormalSym :: Sym.Sym -> Doc
prtReadFormalSym sym = case (isPointer $ Sym.getQuals sym, isScalar $ Sym.getType sym) of
  (True , True )  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (True , False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (False, True )  -> docStr $ ((Sym.getName sym) ++ "_ld")
  (False, False)  -> docStr $ ((Sym.getName sym) ++ "_ld")

  where

    nameWithTypeCast :: Sym.Sym -> String
    nameWithTypeCast sym = case Sym.getType sym of
      T.Vec      -> "((__m128 *)(" ++ (Sym.getName sym) ++ "))"
      T.IVec     -> "((__m128i *)(" ++ (Sym.getName sym) ++ "))"
      T.DVec     -> "((__m256d *)(" ++ (Sym.getName sym) ++ "))"
      T.F        -> (Sym.getName sym)
      T.D        -> (Sym.getName sym)
      T.I        -> (Sym.getName sym)
      T.L        -> (Sym.getName sym)
      T.Var s    -> (Sym.getName sym)

prtReadFormalSymN :: Sym.Sym -> Int -> Doc
prtReadFormalSymN sym n = case (isPointer $ Sym.getQuals sym, isScalar $ Sym.getType sym) of
  (True , True )  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (True , False)  -> docStr $ "(*" ++ (nameWithTypeCast sym) ++ ")"
  (False, True )  -> docStr $ ((Sym.getName sym) ++ "_ld_" ++ show n)
  (False, False)  -> docStr $ ((Sym.getName sym) ++ "_ld_" ++ show n)

  where

    nameWithTypeCast :: Sym.Sym -> String
    nameWithTypeCast sym = case Sym.getType sym of
      T.Vec      -> "((__m128 *)(" ++ (Sym.getName sym) ++ "))"
      T.IVec     -> "((__m128i *)(" ++ (Sym.getName sym) ++ "))"
      T.DVec     -> "((__m256d *)(" ++ (Sym.getName sym) ++ "))"
      T.F        -> (Sym.getName sym)
      T.D        -> (Sym.getName sym)
      T.I        -> (Sym.getName sym)
      T.L        -> (Sym.getName sym)
      T.Var s    -> (Sym.getName sym)

prtRefFormalSym :: Sym.Sym -> Doc
prtRefFormalSym sym = case Sym.getType sym of
  T.Vec      -> docStr $ "_mm_load_ps(" ++ (Sym.getName sym) ++ ")"
  T.IVec     -> docStr $ "_mm_load_si128((__m128i const *)(" ++ (Sym.getName sym) ++ "))"
  T.DVec     -> docStr $ "((__m256d *)(" ++ (Sym.getName sym) ++ "))"
  T.F        -> docStr $ (Sym.getName sym)
  T.I        -> docStr $ (Sym.getName sym)
  T.Var s    -> docStr $ (Sym.getName sym)

prtRefFormalSymN :: Sym.Sym -> Int -> Doc
prtRefFormalSymN sym n = case Sym.getType sym of
  T.Vec      -> docStr $ "_mm_load_ps("    ++ (Sym.getName sym) ++ " + " ++ show (4 * (n-1)) ++ ")"
  T.IVec     -> docStr $ "_mm_load_si128((__m128i const *)(" ++ (Sym.getName sym) ++ " + " ++ show (4 * (n-1)) ++ "))"
  T.DVec     -> docStr $ "_mm256_load_pd("    ++ (Sym.getName sym) ++ " + " ++ show (2 * (n-1)) ++ ")"
  T.F        -> docStr $ (Sym.getName sym)
  T.I        -> docStr $ (Sym.getName sym)
  T.Var s    -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"

prtArrayFormalSym :: Sym.Sym -> Doc
prtArrayFormalSym sym = case Sym.getType sym of
  T.Vec      -> docStr $ "((__m128 *)(" ++ (Sym.getName sym) ++ "))"
  T.IVec     -> docStr $ "((__m128i *)(" ++ (Sym.getName sym) ++ "))"
  T.DVec     -> docStr $ "((__m128d *)(" ++ (Sym.getName sym) ++ "))"
  T.F        -> docStr $ (Sym.getName sym)
  T.I        -> docStr $ (Sym.getName sym)
  T.Var s    -> docStr $ (Sym.getName sym)

prtReadIdentSymN :: Sym.Sym -> Int -> Doc
prtReadIdentSymN sym n = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtVarSymN sym n
  Sym.KindFormalVariable -> prtReadFormalSymN sym n 
  _                      -> error $ "[CodeGenAVX] prtAccessIdentSym: TODO: " ++ show sym

prtAssignIdentSymN :: Sym.Sym -> Int -> Doc
prtAssignIdentSymN sym n = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtSymN sym n
  Sym.KindFormalVariable -> prtAccessFormalSym sym
  _                      -> error $ "[CodeGenAVX] prtAccessIdentSym: TODO: " ++ show sym

prtAccessIdentSym :: Sym.Sym -> AccessMode -> Doc
prtAccessIdentSym sym ReadMode = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtSym sym
  Sym.KindFormalVariable -> prtReadFormalSym sym 
  _                      -> error $ "[CodeGenAVX] prtAccessIdentSym: TODO: " ++ show sym

prtAccessIdentSym sym AssignMode = case (Sym.getKind sym) of
  Sym.KindVariable       -> prtSym sym
  Sym.KindFormalVariable -> prtAccessFormalSym sym 
  _                      -> error $ "[CodeGenAVX] prtAccessIdentSym: TODO: " ++ show sym

prtSymOfExp :: IR.Exp -> Doc
prtSymOfExp exp = prtSym $ IR.getSymFromExp exp

prtSymOfExpN :: IR.Exp -> Int -> Doc
prtSymOfExpN exp n = prtSymN (IR.getSymFromExp exp) n

docStr :: String -> Doc
docStr str = doc (showString str)

instance CodeGenAVX IR.DecInitExp where
  prt e = case e of
    IR.DExp sym exp          -> concatD [prt exp]

instance CodeGenAVX IR.DecInit where
  prt d = case d of
    IR.DeclInit id []        -> concatD []
    IR.DeclInit id [initExp] -> concatD [prt initExp]
    _                        -> error "???"
    
vLen :: Sym.Sym -> Int
vLen sym = case (Sym.getType sym) of
  T.Vec   -> 1 
  T.IVec  -> 1 
  T.DVec  -> 1 
  T.F     -> 1 
  T.I     -> 1 
  T.D     -> 1 
  T.Var _ -> 1 
  _       -> error $ "vLen: TODO: " ++ show sym

nElem :: Sym.Sym -> Int
nElem sym = case (Sym.getType sym) of
  T.Vec  -> 4 
  T.DVec -> 2 
  T.F    -> 1 
  T.I    -> 1 
  T.D    -> 1 
  _      -> error $ "vLen: TODO: " ++ show sym

instance CodeGenAVX IR.Stm where
  prt e = case e of
    -- IR.SDecl sym ty (IR.DeclInit declid []) ->
    --                              concatD [prtSymDef sym,
    --                                       docStr ";"]

    IR.SDecl sym ty (IR.DeclInit declid []) ->

      emitSDeclV sym (vLen sym) 

      where
  
        emitSDeclV sym 0 = concatD []
        emitSDeclV sym n = concatD
          [ emitSDeclV sym (n - 1)
          , prtSymDefN sym n
          , docStr ";"
          ]

    --IR.SDecl sym ty (IR.DeclInit declid [initExp]) ->
    --                             concatD [prt initExp,
    --                                      prtSymDef sym,
    --                                      docStr "=",
    --                                      prtSym (IR.getSymFromDExp initExp),
    --                                      docStr ";"
    --                                      ]

    IR.SDecl sym ty (IR.DeclInit declid [initExp]) -> concatD

      [ prt initExp
      , emitSDeclWithExpV sym initExp (vLen sym)
      ]

      where
  
        emitSDeclWithExpV sym exp 0 = concatD []
        emitSDeclWithExpV sym exp n = concatD
          [ emitSDeclWithExpV sym exp (n - 1)

          --

          , prtSymDefN sym n
          , docStr "="
          , prtSymN (IR.getSymFromDExp exp) n
          , docStr ";"
          ]


    IR.SAssign sym id exp     -> concatD

      [ prt exp
      , emitAssignV sym exp (vLen sym)
      ]

      where

        emitAssignV sym exp 0 = concatD []
        emitAssignV sym exp n = concatD

          [ emitAssignV sym exp (n-1)
          , prtAssignIdentSymN sym n
          , docStr "="
          , prtSymN (IR.getSymFromExp exp) 1
          , docStr ";"

          ]

    --
    -- Use brute force assignment.
    --
    -- a.xy = v is mapped to.
    --
    -- float tmp[4];
    -- _mm_storeu_ps(tmp, v);
    --
    -- ((float *)&a)[0] = tmp[0];
    -- ((float *)&a)[1] = tmp[1];
    --
    --
    -- TODO: Optimize!
    --       - Use shuffle instruction for (length swizzleIndex) == 4 case.
    --       - AVX4 may have partial update instruction.
    --
    IR.SAssignWithSwizzle sym id swizzleIndex exp
        ->  concatD [ prt exp
                    , prtVtoArray T.F sym tmpSymStr exp
                    , prtAssignWithSwizzle swizzleIndex 0 leftSymStr rightSymStr
                    ]
            
            where

              tmpSymStr :: String
              tmpSymStr = Sym.genSymName T.F

              leftSymStr  = Sym.getName sym
              rightSymStr = tmpSymStr 

              prtAssignWithSwizzle :: [Int] -> Int -> String -> String -> Doc

              prtAssignWithSwizzle []     pos lhs rhs = concatD []
              prtAssignWithSwizzle [d]    pos lhs rhs =
                concatD [ prtAssignWithSwizzleOp d pos lhs rhs ]

              prtAssignWithSwizzle (d:ds) pos lhs rhs =
                concatD [ prtAssignWithSwizzleOp d pos lhs rhs
                        , docStr "\n"
                        , prtAssignWithSwizzle ds (pos + 1) lhs rhs
                        ]

              -- TODO: fix me
              prtAssignWithSwizzleOp :: Int -> Int -> String -> String -> Doc
              prtAssignWithSwizzleOp idx pos lhs rhs =
                docStr ("((float *)&" ++ lhs ++ "_1)[" ++ show idx ++ "]" ++
                        " = " ++ rhs ++ "[" ++ show pos ++ "];")
              
  
              
    IR.SAssignWithField sym id fields exp -> concatD

      [ prt exp
      , docStr "("
      , prtAssignIdentSymN sym 1
      , docStr $ accessorStr (Sym.getQuals sym)
      , docStr $ fieldName (fields !! 0)
      , docStr ")"
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"
      ]

      where

        fieldName :: IR.Field -> String
        fieldName (IR.EField (IR.Ident str)) = str
        
        accessorStr :: [T.Qual] -> String
        accessorStr ty = case ty of 
          [T.InputQual]  -> "."
          [T.OutputQual] -> "."
          [T.InOutQual]  -> "."
          _              -> "."


    IR.SAssignWithArray sym id idxExp exp -> concatD

      -- TODO: support DVec

      [ prt idxExp
      , prt exp
      -- , docStr $ (Sym.getName sym)
      , prtArraySym sym
      , docStr "["
      , prtSymOfExpN idxExp 1
      , docStr "]"
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"
      ]


    --
    -- Compound statement. Enclose the statement in parentheses.
    --
    IR.SBlock stms          -> concatD [docStr "{",
                                        prt stms,
                                        docStr "}"]

    --
    -- Do some tricks.
    --
    -- while (exp) { stm }
    --
    -- is converted to,
    --
    -- expand(exp);
    -- flag = root(exp)
    -- while (flag)) {
    --     stm;
    --     expand(exp);
    --     flag = root(exp);
    -- }
    --
    IR.SWhile exp stms      -> concatD

      [ prt exp

      -- Update flag

      , prt T.I
      , docStr flagReg
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"

      --

      , docStr "while"
      , docStr "("
      , docStr flagReg
      , docStr ")"
      , docStr "{"

      , prt stms
      , prt exp

      -- Update flag

      , docStr flagReg
      , docStr "="
      , prtSymOfExpN exp 1
      , docStr ";"

      , docStr "}"
      ]

      where flagReg = mkTempRegFromTy T.I

    IR.SIf exp ifStms elseStms -> concatD

      [ prt exp
      , docStr "if"
      , docStr "("
      , prtSymN (IR.getSymFromExp exp) 1    -- exp should be int scalar.
      , docStr ")"
      , docStr "{"
      , prt ifStms
      , docStr "}"
      , docStr "else"
      , docStr "{"
      , prt elseStms
      , docStr "}"
      ]

    IR.SReturnVoid          -> concatD

      [ docStr "return"
      , docStr ";"
      ]

    IR.SReturn exp          -> concatD

      [ prt exp
      , emitReturn exp
      ]

      where

        emitReturn exp = concatD
            
            [ docStr "return"
            , prtSymN (IR.getSymFromExp exp) 1
            , docStr ";"
            ]

        dretReg :: String
        dretReg = Sym.genSymName T.DVec
      
    IR.SExp exp          -> concatD

      [ prt exp
      ]


    _ -> error $ "[CodeGenAVX] TODO: " ++ show e

  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, docStr "\n",  prt xs])


instance CodeGenAVX IR.FuncSpec where
  prt f = case f of
    IR.InlineFuncSpec       -> doc $ showString "MUDA_INLINE"
    IR.ForceInlineFuncSpec  -> doc $ showString "MUDA_INLINE"
    IR.AlwaysInlineFuncSpec -> doc $ showString "MUDA_ALWAYS_INLINE"
    IR.StaticFuncSpec       -> doc $ showString "MUDA_STATIC"

  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]



instance CodeGenAVX IR.Prog where
  prt p = case p of
    IR.Program structs funcs -> concatD [prt structs, prt funcs]




instance CodeGenAVX IR.Ident where
  prt (IR.Ident i) = doc (showString i)

convType :: String -> String
convType s = case s of
  "vec"  -> "__m128"
  "dvec" -> "__m256d"
  "ivec" -> "__m128i"
  "lvec" -> "__muda_m256l"
  "int"  -> "int"
  s      -> s

strOfType :: T.Typ -> String
strOfType ty = convType $ T.strOfType ty

instance CodeGenAVX IR.Typ where
  prt (IR.TName e) = case e of
    (IR.Ident tname) -> concatD [doc (showString $ convType tname)] 

instance CodeGenAVX T.Typ where
  prt ty = concatD [doc (showString $ strOfType ty)] 


getConstantInt :: IR.Exp -> Integer
getConstantInt exp = case exp of
  (IR.EItoIV _ (IR.ELoad _ (IR.EInt _ i))) -> i
  _                                        -> error $ "Unknown expression for getConstantInt: " ++ show exp

prtShuffleConstant :: Integer -> Doc
prtShuffleConstant i = 
  concatD [ docStr "_MM_SHUFFLE(",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ",",
            docStr $ show i,
            docStr ")"
          ]


--
-- Emit string to be a header file.
--


prtHeader :: IR.Prog -> Doc
prtHeader p = case p of
  IR.Program structs funcs ->concatD 

    [ docStr commonHeaderString
    , concatD $ map prtHeaderStructDefs structs
    , concatD $ map prtHeaderFuncDefs funcs
    ]

  where

    commonHeaderString = unlines

      [ "//"
      , "// The following code is generated by MUDA compiler"
      , "//"
      , "#include <immintrin.h>"
      -- , ""
      -- , "typedef union {"
      -- , "   __m128 v;" 
      -- , "   float  f[4];" 
      -- , "   int    i[4];" 
      -- , "} vec;"
      -- , ""
      -- , "typedef union {"
      -- , "   __m128 v0;" 
      -- , "   __m128 v1;" 
      -- , "   float  f[8];" 
      -- , "   int    i[8];" 
      -- , "} dvec;"
      , "\n"
      ]

prtHeaderStructDefs :: IR.Struc -> Doc
prtHeaderStructDefs s = case s of
  IR.Struct id mdecs -> concatD [ docStr ("typedef struct " ++ mkStructName id)
                                , docStr "{"
                                , prt mdecs
                                , docStr "}"
                                , prt id
                                , docStr ";\n\n"
                                ]

    where
    
      mkStructName :: IR.Ident -> String
      mkStructName (IR.Ident i) = "_" ++ i


prtHeaderFuncDefs :: IR.Func -> Doc
prtHeaderFuncDefs p = case p of
  IR.Fun specs ty id formaldecs stms 

    -- Skip functions defined with "MUDA_INLINE" or "MUDA_STATIC" 
    | (length specs) > 0  -> concatD []
    | otherwise           -> concatD

      [ docStr "extern"

      -- Return type doesn't have native type.
      , docStr $ T.strOfType (IR.convTypeMUDA ty)
      , prt id
      , docStr "("

      , prt formaldecs

      , docStr ")"
      , docStr ";"
      , docStr "\n"
      ]


substDoc :: String -> [(String, String)] -> Doc
substDoc t b = concatD $ map (doc . showString) (splitBySpace $ substText t b)

splitBySpace :: String -> [String]
splitBySpace = splitRegex (mkRegex " +")

--
-- Template string in Haskell.
--
--
-- binding = [("reg0", "a")
--           ,("reg1", "b")
--           ]
--
-- substText "[[reg0]] = [[reg1]]" binding
--
--   => "a = b"
--
substText = foldl (\ t (n, v) -> subRegex (mkRegex ("\\[\\[" ++ n ++ "\\]\\]")) t v)





-- vim: set ts=2 sw=2 expandtab:

