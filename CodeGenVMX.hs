-------------------------------------------------------------------------------
---- |
---- Module      :  CodeGenVMX
---- Copyright   :  (c) Syoyo Fujita, Luca Barbato
---- License     :  BSD-style
----
---- Maintainer  :  lu_zero@gentoo.org
---- Stability   :  experimental
---- Portability :  GHC 7.6
----
---- CodeGenVMX  :  Code generator for PowerPC VMX/Altivec
----
-------------------------------------------------------------------------------
module CodeGenVMX where

import Debug.Trace

import Data.Char
import qualified IR
import qualified Sym
import qualified TypeMUDA as T

-- pretty-printer grabbed from PrintMUDA.hs generated by the BNF converter
-- with small modification.

-- the top-level printing method
printTree :: (CodeGenVMX a) => a -> String
printTree tree = headerString ++ (render $ prt tree)

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> new i . showChar '{' . new (i+1) . rend (i+1) ts
    -- "} else {" :ts -> trace "else" $ new (i-1) . showString "} else {" . new i . rend i ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    t  : "}" :ts -> showString t . new (i-1) . showString "}" . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    --";"      :ts -> showChar ';' . new i . rend i ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    "\n"     :ts -> new i . rend i ts
    t  : "," :ts -> showString t . space "," . rend i ts
    t  : ")" :ts -> showString t . showString ") " . rend i ts
    t  : "]" :ts -> showString t . showChar ']' . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  --new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile isSpace
  new ii  = showChar '\n' . replicateS (4*ii) (showChar ' ') . dropWhile (\x -> x == ' ')
  -- new2 ii  = trace "new2" $ showChar '\n'
  space t = showString t . (\s -> if null s then "" else (' ':s))

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

instance CodeGenVMX Char where
  prt s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

--
-- CodeGenVMX class
--

class CodeGenVMX a where
  prt :: a -> Doc
  prtList :: [a] -> Doc
  prtList = concatD . map prt


instance CodeGenVMX a => CodeGenVMX [a] where
  prt = prtList


prtBinOp :: String -> Sym.Sym -> IR.Exp -> IR.Exp -> Doc
prtBinOp opStr sym e0 e1 = concatD [
  prt e0,
  prt e1,
  prtSymConstDef sym,
  docStr " = ",
  docStr (opStr ++ "("),
  prtSymOfExp e0,
  docStr ", ",
  prtSymOfExp e1, 
  docStr " )",
  docStr ";"
  ]

prtFuncArgSyms :: [IR.Exp] -> Doc
prtFuncArgSyms []     = concatD []
prtFuncArgSyms [e]    = concatD [prtSymOfExp e]
prtFuncArgSyms (e:es) = concatD [prtSymOfExp e, docStr ",", prtFuncArgSyms es]

--
-- Emits string such like,
--
--  float tmpVar[4];
--  _mm_storeu_ps(tmpVar, v);
--  float fvar = tmpVar[0];
--
-- Use _mm_storeu_ps for safety for now,
-- but once it is guaranteed that the address stored is aligned to 16 bytes,
-- we could use _mm_store_ps
-- 
--
-- TODO: Refactor! Is there any clever way such like template string in
--       Haskell?
--
prtVtoF :: Sym.Sym -> IR.Exp -> Doc
prtVtoF sym exp =
  concatD [
    docStr $ strOfType T.F,
    docStr $ tmpSymStr ++ "[4]",
    docStr ";",
    docStr "vec_st_unaligned", -- macro or helper function?
    docStr "(",
    docStr tmpSymStr,
    docStr ",",
    prtSymOfExp exp,
    docStr ")",
    docStr ";",
    prtSymConstDef sym,
    docStr "=",
    docStr $ tmpSymStr ++ "[0]",
    docStr ";"
  ]

  where

    tmpSymStr :: String
    tmpSymStr = Sym.genSymName T.F


instance CodeGenVMX IR.Exp where
  prt e = case e of
    -- IR.EIdent sym id     -> concatD [prtSym sym]
    IR.EFloat sym val    -> concatD [prtSymConstDef sym,
                                     docStr "=",
                                     docStr $ show val,
                                     docStr ";"]

    IR.EIdent sym id     -> concatD []    -- Output nothing

    -- tmp = vec_lde(0,&val); vec_splat(tmp, (unsigned)&val%4);

    IR.EFtoV  sym exp    -> concatD [prt exp,
                                     prtSymConstDef sym,
                                     docStr "=",
                                     docStr "FIX_vec_splat( ",
                                     prtSymOfExp exp,
                                     docStr ",0 )",
                                     docStr ";"]

    IR.EVtoF  sym exp    -> concatD [prt exp,
                                     prtVtoF sym exp]
                                    

    --
    -- bin op
    -- TODO: parameterize bin op str
    --
    IR.EAnd   sym e0 e1  -> prtBinOp "vec_and"    sym e0 e1
    IR.EOr    sym e0 e1  -> prtBinOp "vec_or"     sym e0 e1
    IR.EEq    sym e0 e1  -> prtBinOp "vec_cmpeq"  sym e0 e1
    -- vec_neg(vec_cmpeq(e0 e1))
    IR.ENeq   sym e0 e1  -> prtBinOp "FIX_vec_cmpneq" sym e0 e1
    IR.EGt    sym e0 e1  -> prtBinOp "vec_cmpgt"  sym e0 e1
    IR.EGte   sym e0 e1  -> prtBinOp "vec_cmpge"  sym e0 e1
    IR.ELt    sym e0 e1  -> prtBinOp "vec_cmplt"  sym e0 e1
    IR.ELte   sym e0 e1  -> prtBinOp "vec_cmple"  sym e0 e1
    IR.EAdd   sym e0 e1  -> prtBinOp "vec_add"    sym e0 e1
    IR.ESub   sym e0 e1  -> prtBinOp "vec_sub"    sym e0 e1
    -- vec_madd(e0,e1, vzero)
    IR.EMul   sym e0 e1  -> prtBinOp "FIX_vec_madd"  sym e0 e1
    -- Newton-Raphson...
    IR.EDiv   sym e0 e1  -> prtBinOp "FIX_vec_div"    sym e0 e1

    -- vec_madd(e0,vec_re(e1), vzero) 1/4096 relative error
    IR.EDivApprox   sym e0 e1  -> prtBinOp "FIX_vec_appr_div" sym e0 e1

    IR.EFunc  sym id exps 
      | (Sym.getType sym) == T.Void
        -> concatD [concatD $ map prt exps,
                    docStr (IR.stringFromIdent id),
                    docStr "(",
                    prtFuncArgSyms exps,
                    docStr ")",
                    docStr ";"]
      | otherwise
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    docStr (IR.stringFromIdent id),
                    docStr "(",
                    prtFuncArgSyms exps,
                    docStr ")",
                    docStr ";"
                   ]

    --
    -- TODO: Use same code gen for intrinsic functions.
    --

    IR.EVecInit  sym exps 
      | (length exps) == 1
        -- sym of exp is already vectorized, thus just emit assign.
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    prtFuncArgSyms exps,
                    docStr ";"
                   ]

      -- use typeof() ?
      | (length exps) == 4
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    docStr "(vector float)",
                    docStr "{",
                    prtFuncArgSyms exps,
                    docStr "}",
                    docStr ";"
                   ]
      | otherwise
        -> error ("vec() with invalid number of args:" ++ (show $ length exps))

    IR.ESel     sym exps 
        -> concatD [concatD $ map prt exps,
                    prtSymConstDef sym,
                    docStr "=",
                    docStr "vec_sel",
                    docStr "(",
                    prtFuncArgSyms exps,
                    docStr ")",
                    docStr ";"
                   ]

    _ -> error ("[CodeGenVMX] TODO: " ++ (show e))


instance CodeGenVMX IR.Struc where
  prt s = case s of
    IR.Struct mdecs id -> concatD [doc $ showString "struct"]

  prtList ss = case ss of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]


instance CodeGenVMX IR.Func where
  prt f = case f of
    IR.Fun specs ty id formaldecs stms ->
      concatD [prt specs,
               prt ty,
               prt id,
               docStr "(",
               prt formaldecs,
               docStr ")",
               docStr "{",
               prt stms,
               docStr "}",
               docStr "\n"
              ]
    
  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]

--
-- TODO: Handle qual specfier.
--
instance CodeGenVMX IR.FormalDec where
  prt e = case e of
    IR.FormalDecl sym quals ty id -> case (Sym.getQuals sym) of
      [T.InputQual]  -> (concatD [docStr "const", prt ty, prt id])
      [T.InOutQual]  -> (concatD [prt ty, docStr "*", prt id])
      [T.OutputQual] -> (concatD [prt ty, docStr "*", prt id])
      _              -> (concatD [prt ty, prt id])


  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, doc (showString ","), prt xs])


--
-- Print header
--
headerString :: String
headerString = unlines [
  "//",
  "// The following code is generated by MUDA compiler",
  "//",
  "#include <altivec.h>",
  "#ifdef __64bit__",
  "    #error \"64bit env is not yet supported\"",
  "#else",
  "#endif",
  "",
  "#ifdef __GNUC__",
  "static inline void *muda_aligned_addr16(void *addr) {",
  "    return (void *)((((unsigned int)addr) + 15UL) & ~(15UL));",
  "}",
  "#endif",
  "",
  "#ifdef __GNUC__",
  "    #define MUDA_ATTRIB_ALIGN __attribute__((aligned(" ++ align ++ ")))",
  "    #define MUDA_DECL_ALIGN",
  -- TODO check xlc and llvm
  "#else",
  "    #error \"Sorry, MUDA doesn't support your compiler\"",
  "#endif",
  "",
  "",
  ""
  ]
  where
    align = show 16  -- TODO: parameterize

--
-- e.g. _m128 a
--
prtSymDef :: Sym.Sym -> Doc
prtSymDef sym = concatD [prt (Sym.getType sym),
                         doc $ showString $ (Sym.getName sym)]

--
-- e.g. const _m128 a
--
prtSymConstDef :: Sym.Sym -> Doc
prtSymConstDef sym = concatD [docStr "const",
                              prt (Sym.getType sym),
                              docStr (Sym.getName sym)]

prtSym :: Sym.Sym -> Doc
prtSym sym = case (Sym.getQuals sym) of
  [T.InOutQual]  -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  [T.OutputQual] -> docStr $ "(*" ++ (Sym.getName sym) ++ ")"
  _              -> docStr (Sym.getName sym)

prtSymOfExp :: IR.Exp -> Doc
prtSymOfExp exp = prtSym $ IR.getSymFromExp exp

docStr :: String -> Doc
docStr str = doc (showString str)

instance CodeGenVMX IR.Stm where
  prt e = case e of
    IR.SDecl sym ty decinit -> concatD [prtSymDef sym, docStr ";"]
    IR.SAssign sym id exp   -> concatD [prt exp,
                                        prtSym sym,
                                        docStr "=",
                                        prtSym (IR.getSymFromExp exp),
                                        docStr ";"]

    --
    -- Compound statement. Enclose the statement in parentheses.
    --
    IR.SBlock stms          -> concatD [docStr "{",
                                        prt stms,
                                        docStr "}"]

    --
    -- Do some tricks.
    --
    -- while (exp) { stm }
    --
    -- is converted to,
    --
    -- expand(exp);
    -- while (root(exp)) {
    --     stm;
    --     expand(exp);
    -- }
    --
    IR.SWhile exp stms      -> concatD [prt exp,
                                        docStr "while",
                                        docStr "(",
                                        prtSymOfExp exp,
                                        docStr ")",
                                        docStr "{",
                                        prt stms,
                                        prt exp,
                                        docStr "}"]

    IR.SIf exp ifStms elseStms
                            -> concatD [prt exp,
                                        docStr "if",
                                        docStr "(",
                                        prtSym (IR.getSymFromExp exp),
                                        docStr ")",
                                        docStr "{",
                                        prt ifStms,
                                        docStr "}",
                                        docStr "else",
                                        docStr "{",
                                        prt elseStms,
                                        docStr "}"]

    IR.SReturnVoid          -> concatD [ docStr "return"
                                       , docStr ";"]

    IR.SReturn exp          -> concatD [prt exp,
                                        docStr "return",
                                        prtSym (IR.getSymFromExp exp),
                                        docStr ";"]

    _ -> error $ "[CodeGenVMX] TODO: " ++ show e

  prtList es = case es of
    []   -> (concatD [])
    [x]  -> (concatD [prt x])
    x:xs -> (concatD [prt x, docStr "\n",  prt xs])

{-
instance CodeGenVMX IR.FuncArgs where
    prt e = case e of
        IR.EArg exp -> concatD [prt exp]

    prtList es = case es of
        []   -> concatD []
        [x]  -> concatD [prt x]
        x:xs -> concatD [prt x, doc (showString ","), prt xs]
-}


instance CodeGenVMX IR.FuncSpec where
  prt f = case f of
    IR.InlineFuncSpec       -> doc $ showString "inline"
    IR.ForceInlineFuncSpec  -> doc $ showString "inline"
    IR.AlwaysInlineFuncSpec -> doc $ showString "inline"
    IR.StaticFuncSpec       -> doc $ showString "static"

  prtList fs = case fs of
    [] -> concatD []
    x:xs -> concatD [prt x, prt xs]


instance CodeGenVMX IR.Prog where
  prt p = case p of
    IR.Program structs funcs -> concatD [prt structs, prt funcs]


-- TODO: convert to pointer type.
convQual :: IR.Qual -> String
convQual q = case q of
  IR.InputQual  -> "in"
  IR.OutputQual -> "out"
  IR.InOutQual  -> "inout"


instance CodeGenVMX IR.Qual where
  prt q = concatD [doc (showString $ convQual q)]

  prtList es = case es of
    [] -> (concatD [])
    x:xs -> (concatD [prt x , prt xs])


instance CodeGenVMX IR.Ident where
  prt (IR.Ident i) = doc (showString i)

convType :: String -> String
convType s = case s of
  "vec"  -> "vector float"
  "ivec" -> "vector signed int"
  "int"  -> "int"
  s      -> s

strOfType :: T.Typ -> String
strOfType ty = convType $ T.strOfType ty

instance CodeGenVMX IR.Typ where
  prt (IR.TName e) = case e of
    (IR.Ident tname) -> concatD [doc (showString $ convType tname)] 

instance CodeGenVMX T.Typ where
  prt ty = concatD [doc (showString $ strOfType ty)] 

-- vim: set ts=2 sw=2 expandtab:

